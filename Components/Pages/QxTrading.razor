@page "/qx"
@implements IDisposable
@inject QubicBackendService Backend
@inject SeedSessionService Seed
@inject TickMonitorService TickMonitor
@inject TransactionTrackerService TxTracker
@inject QubicSettingsService Settings
@inject AssetRegistryService AssetRegistry
@inject VaultService Vault

<h4>QX Asset Operations</h4>
<p class="text-muted">Issue assets, transfer shares, and manage orders on the QX decentralized exchange.</p>

@if (_ordersLoading)
{
    <div class="text-muted mb-3"><span class="spinner-border spinner-border-sm me-1"></span> Loading your open orders...</div>
}
else if ((_myAskOrders != null && _myAskOrders.Count > 0) || (_myBidOrders != null && _myBidOrders.Count > 0))
{
    <div class="card mb-3 border-primary">
        <div class="card-header card-header-accent">Your Open Orders</div>
        <div class="card-body">
            <div class="table-responsive">
                <table class="table table-sm table-hover mb-0">
                    <thead>
                        <tr><th>Type</th><th>Asset</th><th>Price</th><th>Shares</th><th></th></tr>
                    </thead>
                    <tbody>
                        @if (_myAskOrders != null)
                        {
                            @foreach (var o in _myAskOrders)
                            {
                                var order = o;
                                var key = $"a:{o.AssetName}:{o.Price}:{o.NumberOfShares}";
                                var isCancelling = IsCancelPending(key);
                                <tr>
                                    <td><span class="badge bg-danger">Ask</span></td>
                                    <td class="mono">@(Qubic.Core.AssetNameHelper.FromUlong(o.AssetName) ?? "?")</td>
                                    <td class="mono">@o.Price.ToString("N0")</td>
                                    <td class="mono">@o.NumberOfShares.ToString("N0")</td>
                                    <td>
                                        <button class="btn btn-sm btn-outline-danger" @onclick="() => CancelAskOrder(order, key)" disabled="@(isCancelling || _pendingCancels.Count > 0)">
                                            @if (isCancelling) { <span class="spinner-border spinner-border-sm me-1"></span> } Cancel
                                        </button>
                                    </td>
                                </tr>
                            }
                        }
                        @if (_myBidOrders != null)
                        {
                            @foreach (var o in _myBidOrders)
                            {
                                var order = o;
                                var key = $"b:{o.AssetName}:{o.Price}:{o.NumberOfShares}";
                                var isCancelling = IsCancelPending(key);
                                <tr>
                                    <td><span class="badge bg-success">Bid</span></td>
                                    <td class="mono">@(Qubic.Core.AssetNameHelper.FromUlong(o.AssetName) ?? "?")</td>
                                    <td class="mono">@o.Price.ToString("N0")</td>
                                    <td class="mono">@o.NumberOfShares.ToString("N0")</td>
                                    <td>
                                        <button class="btn btn-sm btn-outline-danger" @onclick="() => CancelBidOrder(order, key)" disabled="@(isCancelling || _pendingCancels.Count > 0)">
                                            @if (isCancelling) { <span class="spinner-border spinner-border-sm me-1"></span> } Cancel
                                        </button>
                                    </td>
                                </tr>
                            }
                        }
                    </tbody>
                </table>
            </div>
        </div>
    </div>
}

@if (!Seed.HasSeed)
{
    <div class="alert alert-warning">Enter your seed in the top bar to enable signing.</div>
}
else
{
    <ul class="nav nav-tabs mb-3">
        @foreach (var tab in _tabs)
        {
            <li class="nav-item">
                <a class="nav-link @(tab == _activeTab ? "active" : "")" href="" @onclick="() => _activeTab = tab" @onclick:preventDefault>@tab</a>
            </li>
        }
    </ul>

    <div class="row">
        <div class="col-md-8">
            @switch (_activeTab)
            {
                case "Issue":
                    <div class="card">
                        <div class="card-header">Issue Asset</div>
                        <div class="card-body">
                            <div class="mb-2">
                                <label class="form-label-sm">Asset Name (max 7 chars)</label>
                                <input class="form-control form-control-sm" maxlength="7" @bind="_issueName" placeholder="e.g. CFB" />
                            </div>
                            <div class="mb-2">
                                <label class="form-label-sm">Number of Shares</label>
                                <input type="number" class="form-control form-control-sm" @bind="_issueShares" />
                            </div>
                            <div class="mb-2">
                                <label class="form-label-sm">Unit of Measurement (max 7 chars)</label>
                                <input class="form-control form-control-sm" maxlength="7" @bind="_issueUnit" />
                            </div>
                            <div class="mb-2">
                                <label class="form-label-sm">Decimal Places (0-18)</label>
                                <input type="number" class="form-control form-control-sm" min="0" max="18" @bind="_issueDecimals" />
                            </div>
                            <button class="btn btn-primary" @onclick="IssueAsset" disabled="@_sending">
                                @(_sending ? "Issuing..." : "Issue Asset")
                            </button>
                            @if (_fees != null)
                            {
                                <div class="small text-muted mt-1">Fee: @_fees.Value.issuance.ToString("N0") QU</div>
                            }
                        </div>
                    </div>
                    break;

                case "Transfer":
                    <div class="card">
                        <div class="card-header">Transfer Asset</div>
                        <div class="card-body">
                            <AssetSelector @bind-IssuerValue="_xferIssuer" @bind-NameValue="_xferName" />
                            <div class="mb-2">
                                <label class="form-label-sm">New Owner Identity</label>
                                <AddressInput @bind-Value="_xferNewOwner" Placeholder="60 chars" />
                            </div>
                            <div class="mb-2">
                                <label class="form-label-sm">Number of Shares</label>
                                <input type="number" class="form-control form-control-sm" @bind="_xferShares" />
                            </div>
                            <button class="btn btn-primary" @onclick="TransferAsset" disabled="@_sending">
                                @(_sending ? "Transferring..." : "Transfer")
                            </button>
                            @if (_fees != null)
                            {
                                <div class="small text-muted mt-1">Fee: @_fees.Value.transfer.ToString("N0") QU</div>
                            }
                        </div>
                    </div>
                    break;

                case "Ask":
                case "Bid":
                    <div class="card">
                        <div class="card-header">@(_activeTab == "Ask" ? "Ask" : "Bid") Orders</div>
                        <div class="card-body">
                            <div class="mb-2 d-flex gap-2">
                                <button class="btn btn-sm @(_orderAction == "add" ? "btn-primary" : "btn-outline-primary")" @onclick="SetOrderAdd">Add</button>
                                <button class="btn btn-sm @(_orderAction == "remove" ? "btn-primary" : "btn-outline-primary")" @onclick="SetOrderRemove">Remove</button>
                            </div>
                            <AssetSelector @bind-IssuerValue="_orderIssuer" @bind-NameValue="_orderAssetName" />
                            <div class="mb-2">
                                <label class="form-label-sm">Price per Share (QU)</label>
                                <input type="number" class="form-control form-control-sm" @bind="_orderPrice" />
                            </div>
                            <div class="mb-2">
                                <label class="form-label-sm">Number of Shares</label>
                                <input type="number" class="form-control form-control-sm" @bind="_orderShares" />
                            </div>
                            @if (_activeTab == "Bid" && _orderAction == "add" && _orderPrice > 0 && _orderShares > 0)
                            {
                                <div class="small text-muted mb-2">Total: @((_orderPrice * _orderShares).ToString("N0")) QU</div>
                            }
                            <button class="btn btn-primary" @onclick="SubmitOrder" disabled="@_sending">
                                @(_sending ? "Submitting..." : $"{(_orderAction == "add" ? "Add" : "Remove")} {_activeTab} Order")
                            </button>
                            @if (_fees != null && _orderAction == "add")
                            {
                                <div class="small text-muted mt-1">Trade fee: @FormatTradeFee(_fees.Value.trade)</div>
                            }
                        </div>
                    </div>
                    break;

                case "Rights":
                    <div class="card">
                        <div class="card-header">Transfer Management Rights</div>
                        <div class="card-body">
                            <AssetSelector @bind-IssuerValue="_rightsIssuer" @bind-NameValue="_rightsAssetName" />
                            <div class="mb-2">
                                <label class="form-label-sm">Number of Shares</label>
                                <input type="number" class="form-control form-control-sm" @bind="_rightsShares" />
                            </div>
                            <div class="mb-2">
                                <label class="form-label-sm">New Managing Contract</label>
                                <select class="form-select form-select-sm" @bind="_rightsContractIndex">
                                    @foreach (var c in Qubic.Core.QubicContracts.GetManagementRightsTargets())
                                    {
                                        <option value="@c.Index">@c.Name (@c.Index)</option>
                                    }
                                </select>
                            </div>
                            <button class="btn btn-primary" @onclick="TransferRights" disabled="@_sending">
                                @(_sending ? "Transferring..." : "Transfer Rights")
                            </button>
                            @if (_fees != null)
                            {
                                <div class="small text-muted mt-1">Fee: @_fees.Value.transfer.ToString("N0") QU</div>
                            }
                        </div>
                    </div>
                    break;
            }

            @if (_result != null)
            {
                <div class="alert alert-success mt-3">
                    Transaction broadcast! Tx ID: <span class="mono">@_result</span>
                    <div class="mt-1">
                        <a href="https://explorer.qubic.org/network/tx/@_result" target="_blank" rel="noopener" class="me-3">View on Explorer</a>
                        <a href="/history">Transaction History</a>
                    </div>
                </div>
                @if (_activeTab == "Transfer" && Vault.IsUnlocked && !_dismissSaveContact && !string.IsNullOrEmpty(_xferNewOwner) && !Vault.IsKnownAddress(_xferNewOwner))
                {
                    <div class="alert alert-info mt-2 py-2 d-flex align-items-center gap-2 flex-wrap">
                        <i class="bi bi-person-plus"></i>
                        <span class="small">Save <span class="mono">@_xferNewOwner[..12]...</span> to address book?</span>
                        <input type="text" class="form-control form-control-sm" style="width:150px"
                               @bind="_saveContactLabel" placeholder="Label" />
                        <button class="btn btn-sm btn-outline-primary" @onclick="SaveNewContact">Save</button>
                        <button class="btn btn-sm btn-outline-secondary" @onclick="() => _dismissSaveContact = true">
                            <i class="bi bi-x"></i>
                        </button>
                    </div>
                }
            }
            @if (_error != null)
            {
                <div class="alert alert-danger mt-2">@_error</div>
            }
        </div>
    </div>
}

<div class="card mb-3 mt-3">
    <div class="card-header d-flex justify-content-between align-items-center">
        <span>QX Market Overview</span>
        <button class="btn btn-sm btn-outline-primary" @onclick="LoadMarketOverview" disabled="@_marketLoading">
            @(_marketLoading ? "Loading..." : _marketAssets == null ? "Load" : "Refresh")
        </button>
    </div>
    <div class="card-body">
        @if (_marketLoading)
        {
            <div class="text-muted"><span class="spinner-border spinner-border-sm me-1"></span> Querying order books for @AssetRegistry.GetAll().Count assets...</div>
        }
        else if (_marketAssets != null && _marketAssets.Count > 0)
        {
            <div class="small text-muted mb-2">@_marketAssets.Count of @AssetRegistry.GetAll().Count assets with active orders</div>
            <div class="table-responsive">
                <table class="table table-sm table-hover mb-0">
                    <thead>
                        <tr>
                            <th>Asset</th>
                            <th>Issuer</th>
                            <th class="text-end">Best Ask</th>
                            <th class="text-end">Ask Depth</th>
                            <th class="text-end">Best Bid</th>
                            <th class="text-end">Bid Depth</th>
                            <th class="text-end">Spread</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var m in _marketAssets)
                        {
                            <tr>
                                <td class="mono fw-bold">@m.Name</td>
                                <td><AddressDisplay Address="@m.Issuer" TruncateChars="6" ShowCopy="false" /></td>
                                <td class="mono text-end text-danger">@(m.BestAsk > 0 ? m.BestAsk.ToString("N0") : "—")</td>
                                <td class="mono text-end small">@(m.AskDepth > 0 ? m.AskDepth.ToString("N0") : "—")</td>
                                <td class="mono text-end text-success">@(m.BestBid > 0 ? m.BestBid.ToString("N0") : "—")</td>
                                <td class="mono text-end small">@(m.BidDepth > 0 ? m.BidDepth.ToString("N0") : "—")</td>
                                <td class="mono text-end">@(m.BestAsk > 0 && m.BestBid > 0 ? $"{((double)(m.BestAsk - m.BestBid) / m.BestBid * 100):F1}%" : "—")</td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        }
        else if (_marketAssets != null)
        {
            <div class="text-muted">No active orders found.</div>
        }
        @if (_marketError != null)
        {
            <div class="text-danger small mt-1">@_marketError</div>
        }
        @if (_marketAssets == null && _marketError == null)
        {
            <div class="text-muted small">Click <strong>Load</strong> to discover and query all QX-traded assets.</div>
        }
    </div>
</div>

<div class="small text-muted mt-2">
    <i class="bi bi-info-circle me-1"></i>
    To sell or manage your own assets, go to the <a href="/assets">Asset Portfolio</a> page.
</div>

@code {
    private static readonly string[] _tabs = ["Issue", "Transfer", "Ask", "Bid", "Rights"];
    private string _activeTab = "Issue";
    private bool _sending;
    private string? _result;
    private string? _error;
    private (uint issuance, uint transfer, uint trade)? _fees;

    private const int ContractIndex = 1; // QX

    // Market overview
    private bool _marketLoading;
    private string? _marketError;
    private List<MarketAsset>? _marketAssets;
    private record MarketAsset(string Name, string Issuer, long BestAsk, long AskDepth, long BestBid, long BidDepth);

    // Open orders
    private bool _ordersLoading;
    private readonly Dictionary<string, string> _pendingCancels = new(); // orderKey → txHash
    private List<Qubic.Core.Contracts.Qx.EntityAskOrdersOrder>? _myAskOrders;
    private List<Qubic.Core.Contracts.Qx.EntityBidOrdersOrder>? _myBidOrders;

    // Issue
    private string _issueName = "";
    private long _issueShares;
    private string _issueUnit = "";
    private int _issueDecimals;

    // Transfer
    private string _xferName = "";
    private string _xferIssuer = "";
    private string? _xferNewOwner;
    private long _xferShares;

    // Save to address book
    private string? _saveContactLabel;
    private bool _dismissSaveContact;
    private void SaveNewContact()
    {
        if (string.IsNullOrWhiteSpace(_saveContactLabel) || string.IsNullOrEmpty(_xferNewOwner)) return;
        try { Vault.AddContact(_saveContactLabel, _xferNewOwner.Trim()); } catch { }
        _saveContactLabel = null;
        _dismissSaveContact = true;
    }

    // Orders
    private void SetOrderAdd() => _orderAction = "add";
    private void SetOrderRemove() => _orderAction = "remove";
    private string _orderAction = "add";
    private string _orderAssetName = "";
    private string _orderIssuer = "";
    private long _orderPrice;
    private long _orderShares;

    // Rights
    private string _rightsAssetName = "";
    private string _rightsIssuer = "";
    private long _rightsShares;
    private uint _rightsContractIndex;

    protected override async Task OnInitializedAsync()
    {
        TxTracker.OnChanged += OnTrackerChanged;
        // Load fees
        try
        {
            var result = await Backend.QuerySmartContractAsync(ContractIndex, 1, []);
            if (result.Length >= 12)
            {
                _fees = (
                    BitConverter.ToUInt32(result, 0),
                    BitConverter.ToUInt32(result, 4),
                    BitConverter.ToUInt32(result, 8)
                );
            }
        }
        catch { }

        if (Seed.HasSeed && Seed.Identity != null)
            await LoadOpenOrders();
    }

    private async Task LoadOpenOrders()
    {
        if (!Seed.HasSeed || Seed.Identity == null) return;
        _ordersLoading = true;
        try
        {
            var pk = Seed.Identity.Value.PublicKey;
            var askInput = new Qubic.Core.Contracts.Qx.EntityAskOrdersInput { Entity = pk, Offset = 0 }.ToBytes();
            var bidInput = new Qubic.Core.Contracts.Qx.EntityBidOrdersInput { Entity = pk, Offset = 0 }.ToBytes();
            var askTask = Backend.QuerySmartContractAsync(ContractIndex, 4, askInput);
            var bidTask = Backend.QuerySmartContractAsync(ContractIndex, 5, bidInput);
            await Task.WhenAll(askTask, bidTask);

            if (askTask.Result.Length >= Qubic.Core.Contracts.Qx.EntityAskOrdersOrder.Size)
                _myAskOrders = Qubic.Core.Contracts.Qx.EntityAskOrdersOutput.FromBytes(askTask.Result)
                    .Orders.Where(o => o.NumberOfShares > 0).ToList();
            if (bidTask.Result.Length >= Qubic.Core.Contracts.Qx.EntityBidOrdersOrder.Size)
                _myBidOrders = Qubic.Core.Contracts.Qx.EntityBidOrdersOutput.FromBytes(bidTask.Result)
                    .Orders.Where(o => o.NumberOfShares > 0).ToList();
        }
        catch { }
        finally { _ordersLoading = false; }
    }

    private async Task CancelAskOrder(Qubic.Core.Contracts.Qx.EntityAskOrdersOrder order, string key)
    {
        try
        {
            var tick = await GetTick();
            var payload = new Qubic.Core.Contracts.Qx.RemoveFromAskOrderPayload
            {
                Issuer = order.Issuer, AssetName = order.AssetName,
                Price = order.Price, NumberOfShares = order.NumberOfShares
            };
            var dest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(Qubic.Core.QubicContracts.GetContractPublicKey(ContractIndex));
            var tx = Seed.CreateAndSignTransaction(dest, 0, tick, payload);
            var result = await Backend.BroadcastTransactionAsync(tx);
            var name = Qubic.Core.AssetNameHelper.FromUlong(order.AssetName) ?? "?";
            TxTracker.Track(new TrackedTransaction { Hash = result.TransactionId, Source = Seed.Identity?.ToString() ?? "",
                Destination = dest.ToString(), Amount = 0, TargetTick = tick,
                InputType = payload.InputType, PayloadHex = Convert.ToHexString(payload.GetPayloadBytes()),
                Description = $"Cancel Ask {name}: {order.NumberOfShares:N0} @ {order.Price:N0} QU",
                RawData = Convert.ToHexString(tx.GetRawBytes()) });
            _pendingCancels[key] = result.TransactionId;
        }
        catch { }
    }

    private async Task CancelBidOrder(Qubic.Core.Contracts.Qx.EntityBidOrdersOrder order, string key)
    {
        try
        {
            var tick = await GetTick();
            var payload = new Qubic.Core.Contracts.Qx.RemoveFromBidOrderPayload
            {
                Issuer = order.Issuer, AssetName = order.AssetName,
                Price = order.Price, NumberOfShares = order.NumberOfShares
            };
            var dest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(Qubic.Core.QubicContracts.GetContractPublicKey(ContractIndex));
            var tx = Seed.CreateAndSignTransaction(dest, 0, tick, payload);
            var result = await Backend.BroadcastTransactionAsync(tx);
            var name = Qubic.Core.AssetNameHelper.FromUlong(order.AssetName) ?? "?";
            TxTracker.Track(new TrackedTransaction { Hash = result.TransactionId, Source = Seed.Identity?.ToString() ?? "",
                Destination = dest.ToString(), Amount = 0, TargetTick = tick,
                InputType = payload.InputType, PayloadHex = Convert.ToHexString(payload.GetPayloadBytes()),
                Description = $"Cancel Bid {name}: {order.NumberOfShares:N0} @ {order.Price:N0} QU",
                RawData = Convert.ToHexString(tx.GetRawBytes()) });
            _pendingCancels[key] = result.TransactionId;
        }
        catch { }
    }

    private bool IsCancelPending(string orderKey)
    {
        if (!_pendingCancels.TryGetValue(orderKey, out var txHash)) return false;
        var tx = TxTracker.Transactions.FirstOrDefault(t => t.Hash == txHash);
        if (tx == null || tx.Status != TrackedTxStatus.Pending)
        {
            _pendingCancels.Remove(orderKey);
            return false;
        }
        return true;
    }

    private void OnTrackerChanged()
    {
        var anyResolved = false;
        foreach (var (key, txHash) in _pendingCancels.ToList())
        {
            var tx = TxTracker.Transactions.FirstOrDefault(t => t.Hash == txHash);
            if (tx == null || tx.Status != TrackedTxStatus.Pending)
            {
                _pendingCancels.Remove(key);
                anyResolved = true;
            }
        }
        if (anyResolved)
            _ = InvokeAsync(async () => { await LoadOpenOrders(); StateHasChanged(); });
        else
            InvokeAsync(StateHasChanged);
    }

    private async Task IssueAsset()
    {
        _sending = true; _error = null; _result = null;
        try
        {
            if (string.IsNullOrWhiteSpace(_issueName)) { _error = "Asset name is required."; return; }
            if (_issueShares <= 0) { _error = "Number of shares must be positive."; return; }

            var tick = await GetTick();
            var payload = new Qubic.Core.Contracts.Qx.IssueAssetPayload
            {
                AssetName = AssetNameHelper.ToUlong(_issueName.Trim()),
                NumberOfShares = _issueShares,
                UnitOfMeasurement = string.IsNullOrWhiteSpace(_issueUnit) ? 0 : AssetNameHelper.ToUlong(_issueUnit.Trim()),
                NumberOfDecimalPlaces = (sbyte)_issueDecimals
            };
            long amount = _fees?.issuance ?? 0;
            await BroadcastAndTrack(amount, tick, payload, payload.InputType,
                $"QX Issue Asset: {_issueName.Trim()} ({_issueShares:N0} shares)");
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _sending = false; }
    }

    private async Task TransferAsset()
    {
        _sending = true; _error = null; _result = null;
        try
        {
            var issuerErr = IdentityValidation.Validate(_xferIssuer);
            if (issuerErr != null) { _error = "Issuer: " + issuerErr; return; }
            var ownerErr = IdentityValidation.Validate(_xferNewOwner);
            if (ownerErr != null) { _error = "New Owner: " + ownerErr; return; }
            if (string.IsNullOrWhiteSpace(_xferName)) { _error = "Asset name is required."; return; }
            if (_xferShares <= 0) { _error = "Number of shares must be positive."; return; }

            var tick = await GetTick();
            var payload = new Qubic.Core.Contracts.Qx.TransferShareOwnershipAndPossessionPayload
            {
                Issuer = Qubic.Core.Entities.QubicIdentity.FromIdentity(_xferIssuer!.Trim()).PublicKey,
                NewOwnerAndPossessor = Qubic.Core.Entities.QubicIdentity.FromIdentity(_xferNewOwner!.Trim()).PublicKey,
                AssetName = AssetNameHelper.ToUlong(_xferName.Trim()),
                NumberOfShares = _xferShares
            };
            long amount = _fees?.transfer ?? 0;
            await BroadcastAndTrack(amount, tick, payload, payload.InputType,
                $"QX Transfer {_xferName.Trim()}: {_xferShares:N0} shares to {_xferNewOwner!.Trim()[..8]}...");
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _sending = false; }
    }

    private async Task SubmitOrder()
    {
        _sending = true; _error = null; _result = null;
        try
        {
            var issuerErr = IdentityValidation.Validate(_orderIssuer);
            if (issuerErr != null) { _error = "Issuer: " + issuerErr; return; }
            if (string.IsNullOrWhiteSpace(_orderAssetName)) { _error = "Asset name is required."; return; }
            if (_orderPrice <= 0) { _error = "Price must be positive."; return; }
            if (_orderShares <= 0) { _error = "Number of shares must be positive."; return; }

            var tick = await GetTick();
            var issuerPk = Qubic.Core.Entities.QubicIdentity.FromIdentity(_orderIssuer!.Trim()).PublicKey;
            var assetName = AssetNameHelper.ToUlong(_orderAssetName.Trim());
            bool isAsk = _activeTab == "Ask";
            bool isAdd = _orderAction == "add";

            Qubic.Core.Payloads.ITransactionPayload payload;
            long amount = 0;
            string desc;

            if (isAsk && isAdd)
            {
                payload = new Qubic.Core.Contracts.Qx.AddToAskOrderPayload { Issuer = issuerPk, AssetName = assetName, Price = _orderPrice, NumberOfShares = _orderShares };
                desc = $"QX Add Ask: {_orderShares:N0} {_orderAssetName.Trim()} @ {_orderPrice:N0}";
            }
            else if (isAsk && !isAdd)
            {
                payload = new Qubic.Core.Contracts.Qx.RemoveFromAskOrderPayload { Issuer = issuerPk, AssetName = assetName, Price = _orderPrice, NumberOfShares = _orderShares };
                desc = $"QX Remove Ask: {_orderShares:N0} {_orderAssetName.Trim()} @ {_orderPrice:N0}";
            }
            else if (!isAsk && isAdd)
            {
                payload = new Qubic.Core.Contracts.Qx.AddToBidOrderPayload { Issuer = issuerPk, AssetName = assetName, Price = _orderPrice, NumberOfShares = _orderShares };
                amount = _orderPrice * _orderShares;
                desc = $"QX Add Bid: {_orderShares:N0} {_orderAssetName.Trim()} @ {_orderPrice:N0} (total: {amount:N0})";
            }
            else
            {
                payload = new Qubic.Core.Contracts.Qx.RemoveFromBidOrderPayload { Issuer = issuerPk, AssetName = assetName, Price = _orderPrice, NumberOfShares = _orderShares };
                desc = $"QX Remove Bid: {_orderShares:N0} {_orderAssetName.Trim()} @ {_orderPrice:N0}";
            }

            await BroadcastAndTrack(amount, tick, payload, payload.InputType, desc);
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _sending = false; }
    }

    private async Task TransferRights()
    {
        _sending = true; _error = null; _result = null;
        try
        {
            var issuerErr = IdentityValidation.Validate(_rightsIssuer);
            if (issuerErr != null) { _error = "Issuer: " + issuerErr; return; }
            if (string.IsNullOrWhiteSpace(_rightsAssetName)) { _error = "Asset name is required."; return; }
            if (_rightsShares <= 0) { _error = "Number of shares must be positive."; return; }

            var tick = await GetTick();
            var payload = new Qubic.Core.Contracts.Qx.TransferShareManagementRightsPayload
            {
                Asset = new Qubic.Core.Contracts.QubicAsset
                {
                    Issuer = Qubic.Core.Entities.QubicIdentity.FromIdentity(_rightsIssuer!.Trim()).PublicKey,
                    AssetName = AssetNameHelper.ToUlong(_rightsAssetName.Trim())
                },
                NumberOfShares = _rightsShares,
                NewManagingContractIndex = _rightsContractIndex
            };
            await BroadcastAndTrack(0, tick, payload, payload.InputType,
                $"QX Transfer Rights: {_rightsShares:N0} {_rightsAssetName.Trim()} to contract {_rightsContractIndex}");
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _sending = false; }
    }

    private async Task<uint> GetTick()
    {
        return TickMonitor.IsConnected
            ? TickMonitor.Tick + (uint)Settings.TickOffset
            : (await Backend.GetTickInfoAsync()).Tick + (uint)Settings.TickOffset;
    }

    private static string FormatTradeFee(uint billionths)
    {
        var pct = billionths / 10_000_000.0;
        return pct % 1 == 0 ? $"{pct:F0}%" : $"{pct:G}%";
    }

    private async Task BroadcastAndTrack(long amount, uint tick, Qubic.Core.Payloads.ITransactionPayload payload, ushort inputType, string description)
    {
        var dest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(Qubic.Core.QubicContracts.GetContractPublicKey(ContractIndex));
        var tx = Seed.CreateAndSignTransaction(dest, amount, tick, payload);
        var result = await Backend.BroadcastTransactionAsync(tx);
        _result = result.TransactionId;

        TxTracker.Track(new TrackedTransaction
        {
            Hash = result.TransactionId,
            Source = Seed.Identity?.ToString() ?? "",
            Destination = dest.ToString(),
            Amount = amount,
            TargetTick = tick,
            InputType = inputType,
            PayloadHex = Convert.ToHexString(payload.GetPayloadBytes()),
            Description = description,
            RawData = Convert.ToHexString(tx.GetRawBytes())
        });
    }

    private async Task LoadMarketOverview()
    {
        _marketLoading = true;
        _marketAssets = null;
        _marketError = null;
        StateHasChanged();
        try
        {
            // Refresh asset registry from network if stale (auto once/day)
            await AssetRegistry.RefreshFromNetworkAsync(Backend);

            var assets = AssetRegistry.GetAll();
            if (assets.Count == 0)
            {
                _marketAssets = [];
                _marketError = "No assets found. Check your RPC connection.";
                return;
            }

            // Query order books for all assets in parallel
            var results = new List<MarketAsset>();
            var tasks = new List<(string Name, string Issuer, Task<byte[]> AskTask, Task<byte[]> BidTask)>();

            foreach (var asset in assets)
            {
                try
                {
                    var issuerPk = Qubic.Core.Entities.QubicIdentity.FromIdentity(asset.Issuer).PublicKey;
                    var assetNameUlong = AssetNameHelper.ToUlong(asset.Name);
                    var askInput = new Qubic.Core.Contracts.Qx.AssetAskOrdersInput
                        { Issuer = issuerPk, AssetName = assetNameUlong, Offset = 0 }.ToBytes();
                    var bidInput = new Qubic.Core.Contracts.Qx.AssetBidOrdersInput
                        { Issuer = issuerPk, AssetName = assetNameUlong, Offset = 0 }.ToBytes();
                    tasks.Add((asset.Name, asset.Issuer,
                        Backend.QuerySmartContractAsync(ContractIndex, 2, askInput),
                        Backend.QuerySmartContractAsync(ContractIndex, 3, bidInput)));
                }
                catch { /* skip assets with invalid identity */ }
            }

            try { await Task.WhenAll(tasks.SelectMany(t => new Task[] { t.AskTask, t.BidTask })); }
            catch { /* individual results checked below */ }

            foreach (var (name, issuer, askTask, bidTask) in tasks)
            {
                long bestAsk = 0, askDepth = 0, bestBid = 0, bidDepth = 0;
                try
                {
                    if (askTask.IsCompletedSuccessfully && askTask.Result.Length >= Qubic.Core.Contracts.Qx.AssetAskOrdersOrder.Size)
                    {
                        var asks = Qubic.Core.Contracts.Qx.AssetAskOrdersOutput.FromBytes(askTask.Result)
                            .Orders.Where(o => o.NumberOfShares > 0).ToList();
                        if (asks.Count > 0)
                        {
                            bestAsk = asks.Min(o => o.Price);
                            askDepth = asks.Sum(o => o.NumberOfShares);
                        }
                    }
                }
                catch { }
                try
                {
                    if (bidTask.IsCompletedSuccessfully && bidTask.Result.Length >= Qubic.Core.Contracts.Qx.AssetBidOrdersOrder.Size)
                    {
                        var bids = Qubic.Core.Contracts.Qx.AssetBidOrdersOutput.FromBytes(bidTask.Result)
                            .Orders.Where(o => o.NumberOfShares > 0).ToList();
                        if (bids.Count > 0)
                        {
                            bestBid = bids.Max(o => o.Price);
                            bidDepth = bids.Sum(o => o.NumberOfShares);
                        }
                    }
                }
                catch { }

                if (bestAsk > 0 || bestBid > 0)
                    results.Add(new MarketAsset(name, issuer, bestAsk, askDepth, bestBid, bidDepth));
            }

            _marketAssets = results.OrderByDescending(m => m.BidDepth + m.AskDepth).ToList();
        }
        catch (Exception ex) { _marketAssets = []; _marketError = ex.Message; }
        finally { _marketLoading = false; }
    }

    public void Dispose()
    {
        TxTracker.OnChanged -= OnTrackerChanged;
    }
}
