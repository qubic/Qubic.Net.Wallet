@page "/msvault"
@implements IDisposable
@inject QubicBackendService Backend
@inject SeedSessionService Seed
@inject TickMonitorService TickMonitor
@inject TransactionTrackerService TxTracker
@inject QubicSettingsService Settings
@inject Qubic.Services.Storage.WalletStorageService WalletStorage
@inject QubicStaticService StaticData

<h4>MSVault (Multisig)</h4>
<p class="text-muted">Manage multisig vaults: register, deposit, release, and vote on fee changes.</p>

@if (_vaultsLoading)
{
    <div class="text-muted mb-3"><span class="spinner-border spinner-border-sm me-1"></span> Loading your vaults...</div>
}
else if (_vaultSummaries != null && _vaultSummaries.Count > 0)
{
    <div class="card mb-3 border-primary">
        <div class="card-header card-header-accent d-flex justify-content-between align-items-center">
            <span>Your Vaults (@_vaultSummaries.Count)</span>
            <button class="btn btn-sm btn-outline-light" @onclick="RefreshVaults" disabled="@_vaultsLoading">
                <i class="bi bi-arrow-clockwise"></i>
            </button>
        </div>
        <div class="card-body">
            @foreach (var v in _vaultSummaries)
            {
                <div class="card mb-2">
                    <div class="card-body p-2">
                        <div class="d-flex justify-content-between align-items-start">
                            <div>
                                <strong class="mono">Vault #@v.Id</strong>
                                <span class="text-muted ms-2 small">@v.Name</span>
                            </div>
                            <div class="d-flex flex-wrap gap-1 justify-content-end">
                                <span class="badge bg-primary">@v.Balance.ToString("N0") QU</span>
                                @foreach (var ab in v.AssetBalances)
                                {
                                    <span class="badge bg-info text-dark">@ab.Balance.ToString("N0") @ab.Name</span>
                                }
                            </div>
                        </div>
                        <div class="small mt-1">
                            <span class="text-muted">Owners:</span> @v.OwnerCount
                            <span class="text-muted ms-2">Required Approvals:</span> @v.RequiredApprovals
                        </div>
                        @if (v.PendingReleases.Count > 0)
                        {
                            @foreach (var rel in v.PendingReleases)
                            {
                                var vaultId = v.Id;
                                var relAmount = rel.Amount;
                                var relDest = rel.Destination;
                                var isBroadcasting = _pendingApproval is { } pa && pa.vaultId == vaultId && pa.amount == relAmount && pa.dest == relDest;
                                var hasPendingTx = HasPendingReleaseTx(vaultId);
                                var isPending = isBroadcasting || hasPendingTx;
                                <div class="card mt-2 @(isPending ? "border-info" : "border-warning")">
                                    <div class="card-body p-2">
                                        <div class="d-flex align-items-center gap-2 small">
                                            @if (isPending)
                                            {
                                                <span class="spinner-border spinner-border-sm text-info"></span>
                                            }
                                            <span class="badge @(rel.Approvals >= (int)rel.RequiredApprovals ? "bg-success" : "bg-warning text-dark")">
                                                @rel.Approvals/@rel.RequiredApprovals approvals
                                            </span>
                                            <span>Release <strong>@rel.Amount.ToString("N0") QU</strong> to</span>
                                            <AddressDisplay Address="@rel.Destination" TruncateChars="8" />
                                        </div>
                                        <div class="mt-1">
                                            @foreach (var owner in rel.ApprovedBy)
                                            {
                                                <div class="small d-flex align-items-center gap-1">
                                                    <i class="bi bi-check-circle-fill text-success"></i>
                                                    <AddressDisplay Address="@owner" TruncateChars="6" ShowCopy="false" />
                                                </div>
                                            }
                                            @foreach (var owner in rel.NotApprovedBy)
                                            {
                                                <div class="small d-flex align-items-center gap-1">
                                                    <i class="bi bi-circle text-muted"></i>
                                                    <AddressDisplay Address="@owner" TruncateChars="6" ShowCopy="false" />
                                                </div>
                                            }
                                        </div>
                                        @if (rel.CurrentWalletCanApprove)
                                        {
                                            @if (isPending)
                                            {
                                                <div class="mt-1 small text-info">
                                                    <span class="spinner-border spinner-border-sm me-1"></span> Release transaction pending...
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-warning mt-1" disabled="@_sending"
                                                        @onclick="() => ApproveRelease(vaultId, relAmount, relDest)">
                                                    <i class="bi bi-pen"></i> Approve Release
                                                </button>
                                            }
                                        }
                                    </div>
                                </div>
                            }
                        }
                        @if (v.PendingAssetReleases.Count > 0)
                        {
                            @foreach (var ar in v.PendingAssetReleases)
                            {
                                var vid = v.Id;
                                var arIssuer = ar.Issuer; var arName = ar.AssetName;
                                var arAmount = ar.Amount; var arDest = ar.Destination;
                                var isAssetBroadcasting = _pendingAssetApproval is { } aap && aap.vaultId == vid && aap.assetName == arName && aap.amount == arAmount && aap.dest == arDest;
                                var hasAssetPendingTx = HasPendingReleaseTx(vid);
                                var isAssetPending = isAssetBroadcasting || hasAssetPendingTx;
                                <div class="card mt-2 @(isAssetPending ? "border-info" : "border-warning")">
                                    <div class="card-body p-2">
                                        <div class="d-flex align-items-center gap-2 small">
                                            @if (isAssetPending)
                                            {
                                                <span class="spinner-border spinner-border-sm text-info"></span>
                                            }
                                            <span class="badge @(ar.Approvals >= (int)ar.RequiredApprovals ? "bg-success" : "bg-warning text-dark")">
                                                @ar.Approvals/@ar.RequiredApprovals approvals
                                            </span>
                                            <span>Release <strong>@ar.Amount.ToString("N0") @ar.AssetName</strong> to</span>
                                            <AddressDisplay Address="@ar.Destination" TruncateChars="8" />
                                        </div>
                                        <div class="mt-1">
                                            @foreach (var owner in ar.ApprovedBy)
                                            {
                                                <div class="small d-flex align-items-center gap-1">
                                                    <i class="bi bi-check-circle-fill text-success"></i>
                                                    <AddressDisplay Address="@owner" TruncateChars="6" ShowCopy="false" />
                                                </div>
                                            }
                                            @foreach (var owner in ar.NotApprovedBy)
                                            {
                                                <div class="small d-flex align-items-center gap-1">
                                                    <i class="bi bi-circle text-muted"></i>
                                                    <AddressDisplay Address="@owner" TruncateChars="6" ShowCopy="false" />
                                                </div>
                                            }
                                        </div>
                                        @if (ar.CurrentWalletCanApprove)
                                        {
                                            @if (isAssetPending)
                                            {
                                                <div class="mt-1 small text-info">
                                                    <span class="spinner-border spinner-border-sm me-1"></span> Release transaction pending...
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-warning mt-1" disabled="@_sending"
                                                        @onclick="() => ApproveAssetRelease(vid, arIssuer, arName, arAmount, arDest)">
                                                    <i class="bi bi-pen"></i> Approve
                                                </button>
                                            }
                                        }
                                    </div>
                                </div>
                            }
                        }
                        @if (v.DetailError != null)
                        {
                            <div class="small text-danger mt-1">@v.DetailError</div>
                        }
                        @if (v.OwnerIdentities.Length > 0)
                        {
                            <details class="mt-1">
                                <summary class="small text-muted" style="cursor:pointer">Show owners</summary>
                                <div class="mt-1">
                                    @foreach (var owner in v.OwnerIdentities)
                                    {
                                        <div><AddressDisplay Address="@owner" /></div>
                                    }
                                </div>
                            </details>
                        }
                        <div class="mt-2 d-flex flex-wrap gap-1">
                            <button class="btn btn-sm btn-outline-primary"
                                    @onclick="() => GoToDeposit(v.Id)">Deposit QU</button>
                            <button class="btn btn-sm btn-outline-primary"
                                    @onclick="() => GoToAssetDeposit(v.Id)">Deposit Asset</button>
                            <button class="btn btn-sm btn-outline-warning"
                                    @onclick="() => GoToRelease(v.Id)">Release QU</button>
                            @if (v.AssetBalances.Count > 0)
                            {
                                @foreach (var ab in v.AssetBalances)
                                {
                                    var abIssuer = ab.Issuer; var abName = ab.Name; var abVaultId = v.Id;
                                    <button class="btn btn-sm btn-outline-warning"
                                            @onclick="() => GoToAssetRelease(abVaultId, abIssuer, abName)">Release @ab.Name</button>
                                }
                            }
                            else
                            {
                                <button class="btn btn-sm btn-outline-warning"
                                        @onclick="() => GoToAssetRelease(v.Id)">Release Asset</button>
                            }
                            <button class="btn btn-sm btn-outline-secondary"
                                    @onclick="() => GoToReset(v.Id)">Reset</button>
                        </div>
                    </div>
                </div>
            }
        </div>
    </div>
}

@if (!Seed.HasSeed)
{
    <div class="alert alert-warning">Enter your seed in the top bar to enable signing.</div>
}
else
{
    <ul class="nav nav-tabs mb-3">
        @foreach (var tab in _tabs)
        {
            <li class="nav-item">
                <a class="nav-link @(tab == _activeTab ? "active" : "")" href="" @onclick="() => _activeTab = tab" @onclick:preventDefault>@tab</a>
            </li>
        }
    </ul>

    <div class="row"><div class="col-md-8">
        @switch (_activeTab)
        {
            case "Register":
                <div class="card"><div class="card-header">Register Vault</div><div class="card-body">
                    <div class="mb-2"><label class="form-label-sm">Vault Name</label>
                        <input class="form-control form-control-sm" maxlength="32"
                               @bind="_regVaultName" placeholder="My Vault..." />
                        <div class="form-text">Any name up to 32 characters.</div></div>
                    <div class="mb-2">
                        <label class="form-label-sm">Owners (min 2, max 16 identities)</label>
                        @for (int idx = 0; idx < _regOwners.Count; idx++)
                        {
                            var i = idx;
                            <div class="input-group input-group-sm mb-1">
                                <span class="input-group-text">@(i + 1)</span>
                                <input class="form-control form-control-sm mono @IdentityValidation.CssClass(_regOwners[i])"
                                       value="@_regOwners[i]"
                                       @onchange="(e) => _regOwners[i] = e.Value?.ToString() ?? string.Empty"
                                       placeholder="IDENTITY..." />
                                @if (_regOwners.Count > 2)
                                {
                                    <button class="btn btn-outline-danger btn-sm" @onclick="() => _regOwners.RemoveAt(i)">&times;</button>
                                }
                            </div>
                        }
                        @if (_regOwners.Count < 16)
                        {
                            <button class="btn btn-outline-secondary btn-sm mt-1" @onclick="() => _regOwners.Add(string.Empty)">+ Add Owner</button>
                        }
                        <div class="form-text">The current wallet identity can be one of the owners.</div>
                    </div>
                    <div class="mb-2"><label class="form-label-sm">Required Approvals (min 2)</label>
                        <input type="number" class="form-control form-control-sm" min="2" max="@_regOwners.Count" @bind="_regApprovals" /></div>
                    <button class="btn btn-primary" @onclick="RegisterVault" disabled="@_sending">@(_sending ? "Registering..." : "Register Vault")</button>
                    @if (_fees != null) { <div class="form-text">Fee: @_fees.Value.register.ToString("N0") QU (sent as tx amount)</div> }
                </div></div>
                break;

            case "Deposit":
                <div class="card"><div class="card-header">Deposit to Vault</div><div class="card-body">
                    <div class="mb-2"><label class="form-label-sm">Vault</label>
                        @if (_vaultSummaries is { Count: > 0 })
                        {
                            <select class="form-select form-select-sm mb-1" @bind="_depVaultId">
                                @foreach (var vs in _vaultSummaries)
                                {
                                    <option value="@vs.Id">#@vs.Id — @vs.Name</option>
                                }
                            </select>
                        }
                        <input type="number" class="form-control form-control-sm" min="0" @bind="_depVaultId"
                               placeholder="Or enter vault ID manually" /></div>
                    <div class="mb-2"><label class="form-label-sm">Amount (QU)</label>
                        <input type="number" class="form-control form-control-sm" min="1" @bind="_depAmount" /></div>
                    <button class="btn btn-primary" @onclick="Deposit" disabled="@_sending">@(_sending ? "Depositing..." : "Deposit")</button>
                    @if (_fees != null) { <div class="form-text">Fee: @_fees.Value.deposit.ToString("N0") QU</div> }
                </div></div>
                break;

            case "Release":
                <div class="card"><div class="card-header">Release / Reset</div><div class="card-body">
                    <div class="mb-2">
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="relMode" id="relModeRelease" checked="@(!_resetMode)" @onchange="() => _resetMode = false" />
                            <label class="form-check-label" for="relModeRelease">Release To</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="relMode" id="relModeReset" checked="@_resetMode" @onchange="() => _resetMode = true" />
                            <label class="form-check-label" for="relModeReset">Reset Release</label>
                        </div>
                    </div>
                    <div class="mb-2"><label class="form-label-sm">Vault</label>
                        @if (_vaultSummaries is { Count: > 0 })
                        {
                            <select class="form-select form-select-sm mb-1" @bind="_relVaultId">
                                @foreach (var vs in _vaultSummaries)
                                {
                                    <option value="@vs.Id">#@vs.Id — @vs.Name</option>
                                }
                            </select>
                        }
                        <input type="number" class="form-control form-control-sm" min="0" @bind="_relVaultId"
                               placeholder="Or enter vault ID manually" /></div>
                    @if (!_resetMode)
                    {
                        <div class="mb-2"><label class="form-label-sm">Destination Identity</label>
                            <input class="form-control form-control-sm mono @IdentityValidation.CssClass(_relDest)"
                                   @bind="_relDest" placeholder="IDENTITY..." /></div>
                        <div class="mb-2"><label class="form-label-sm">Amount (QU)</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_relAmount" /></div>
                    }
                    <button class="btn btn-primary" @onclick="ReleaseOrReset" disabled="@_sending">
                        @(_sending ? "Sending..." : (_resetMode ? "Reset Release" : "Release To"))
                    </button>
                    @if (_fees != null) { <div class="form-text">Fee: @((_resetMode ? _fees.Value.reset : _fees.Value.release).ToString("N0")) QU</div> }
                </div></div>
                break;

            case "Vote Fee":
                <div class="card"><div class="card-header">Vote Fee Change</div><div class="card-body">
                    <p class="small text-muted">Propose new fee values for vault operations.</p>
                    <div class="row g-2 mb-2">
                        <div class="col-md-4"><label class="form-label-sm">New Registering Fee</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_vfRegFee" /></div>
                        <div class="col-md-4"><label class="form-label-sm">New Release Fee</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_vfRelFee" /></div>
                        <div class="col-md-4"><label class="form-label-sm">New Reset Fee</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_vfResetFee" /></div>
                    </div>
                    <div class="row g-2 mb-2">
                        <div class="col-md-4"><label class="form-label-sm">New Holding Fee</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_vfHoldFee" /></div>
                        <div class="col-md-4"><label class="form-label-sm">New Deposit Fee</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_vfDepFee" /></div>
                        <div class="col-md-4"><label class="form-label-sm">Burn Fee</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_vfBurnFee" /></div>
                    </div>
                    <button class="btn btn-primary" @onclick="VoteFeeChange" disabled="@_sending">@(_sending ? "Voting..." : "Vote Fee Change")</button>
                    <div class="form-text">No fee for voting.</div>
                </div></div>
                break;

            case "Assets":
                <div class="card"><div class="card-header">Asset Operations</div><div class="card-body">
                    <div class="mb-2">
                        <select class="form-select form-select-sm" @bind="_assetOp">
                            <option value="deposit">Deposit Asset</option>
                            <option value="release">Release Asset To</option>
                            <option value="reset">Reset Asset Release</option>
                            <option value="revoke">Revoke Asset Management Rights</option>
                        </select>
                    </div>
                    @if (_assetOp != "revoke")
                    {
                        <div class="mb-2"><label class="form-label-sm">Vault</label>
                            @if (_vaultSummaries is { Count: > 0 })
                            {
                                <select class="form-select form-select-sm mb-1" @bind="_aVaultId">
                                    @foreach (var vs in _vaultSummaries)
                                    {
                                        <option value="@vs.Id">#@vs.Id — @vs.Name</option>
                                    }
                                </select>
                            }
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_aVaultId"
                                   placeholder="Or enter vault ID manually" /></div>
                    }
                    <AssetSelector @bind-IssuerValue="_aIssuer" @bind-NameValue="_aName" />
                    @if (_assetOp is "deposit" or "release" or "revoke")
                    {
                        <div class="mb-2"><label class="form-label-sm">@(_assetOp == "revoke" ? "Number of Shares" : "Amount")</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_aAmount" /></div>
                    }
                    @if (_assetOp == "release")
                    {
                        <div class="mb-2"><label class="form-label-sm">Destination Identity</label>
                            <input class="form-control form-control-sm mono @IdentityValidation.CssClass(_aDest)"
                                   @bind="_aDest" placeholder="IDENTITY..." /></div>
                    }
                    <button class="btn btn-primary" @onclick="AssetOp" disabled="@_sending">@(_sending ? "Sending..." : "Submit")</button>
                </div></div>
                break;

            case "Query":
                <div class="card"><div class="card-header">Query MSVault</div><div class="card-body">
                    <div class="mb-3">
                        <label class="form-label-sm">Query Function</label>
                        <select class="form-select form-select-sm" @bind="_queryFunc">
                            <option value="5">Get Vaults (by owner)</option>
                            <option value="7">Get Balance</option>
                            <option value="8">Get Vault Name</option>
                            <option value="11">Get Vault Owners</option>
                            <option value="6">Get Release Status</option>
                            <option value="12">Is Shareholder</option>
                            <option value="10">Get Fees</option>
                        </select>
                    </div>

                    @if (_queryFunc is 5 or 12)
                    {
                        <div class="mb-2"><label class="form-label-sm">Identity</label>
                            <input class="form-control form-control-sm mono @IdentityValidation.CssClass(_qIdentity)"
                                   @bind="_qIdentity" @bind:event="oninput" placeholder="IDENTITY..." /></div>
                    }
                    @if (_queryFunc is 6 or 7 or 8 or 11)
                    {
                        <div class="mb-2"><label class="form-label-sm">Vault ID</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_qVaultId" /></div>
                    }

                    <button class="btn btn-primary" @onclick="RunQuery" disabled="@_querying">
                        @(_querying ? "Querying..." : "Query")
                    </button>

                    @if (_queryResult != null)
                    {
                        <div class="mt-3">
                            <table class="table table-sm table-bordered">
                                <tbody>
                                    @foreach (var kv in _queryResult)
                                    {
                                        <tr><th class="text-muted" style="width:40%">@kv.Key</th><td class="mono">@kv.Value</td></tr>
                                    }
                                </tbody>
                            </table>
                        </div>
                    }
                </div></div>
                break;

            case "History":
                <div class="card"><div class="card-header d-flex justify-content-between align-items-center">
                    <span>MSVault History</span>
                    <button class="btn btn-sm btn-outline-light" @onclick="LoadHistory" disabled="@_histLoading">
                        <i class="bi bi-arrow-clockwise"></i>
                    </button>
                </div><div class="card-body">
                    @if (!WalletStorage.IsOpen)
                    {
                        <div class="alert alert-info mb-0">Open the wallet to view history (synced log events).</div>
                    }
                    else if (_histLoading)
                    {
                        <div class="text-muted"><span class="spinner-border spinner-border-sm me-1"></span> Loading...</div>
                    }
                    else if (_histEntries == null || _histEntries.Count == 0)
                    {
                        <div class="text-muted">No MSVault events found. Events are synced in the background from the network.</div>
                    }
                    else
                    {
                        @if (_histVaultFilter.HasValue)
                        {
                            <div class="mb-2">
                                <span class="badge bg-primary me-1">Vault #@_histVaultFilter</span>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="() => { _histVaultFilter = null; LoadHistory(); }">Show all</button>
                            </div>
                        }
                        <div class="table-responsive">
                            <table class="table table-sm table-hover mb-0">
                                <thead><tr>
                                    <th>Time</th><th>Tick</th><th>Operation</th><th>Vault</th>
                                    <th>Status</th><th>Amount</th><th>Destination</th><th>Initiator</th>
                                </tr></thead>
                                <tbody>
                                    @foreach (var e in _histEntries)
                                    {
                                        <tr class="@(e.IsFailure ? "table-danger" : e.IsPending ? "table-warning" : "")">
                                            <td class="small text-nowrap">@e.Time</td>
                                            <td class="mono small">@e.Tick.ToString("N0")</td>
                                            <td><span class="badge @e.OpBadgeClass">@e.Operation</span></td>
                                            <td class="mono">@(e.VaultId > 0 ? $"#{e.VaultId}" : "—")</td>
                                            <td><span class="badge @e.StatusBadgeClass small">@e.StatusText</span></td>
                                            <td class="mono small">@(e.Amount > 0 ? e.Amount.ToString("N0") + " QU" : "")</td>
                                            <td>
                                                @if (!string.IsNullOrEmpty(e.Destination))
                                                {
                                                    <AddressDisplay Address="@e.Destination" TruncateChars="6" ShowCopy="false" />
                                                }
                                            </td>
                                            <td>
                                                @if (!string.IsNullOrEmpty(e.Initiator))
                                                {
                                                    <AddressDisplay Address="@e.Initiator" TruncateChars="6" ShowCopy="false" />
                                                }
                                            </td>
                                        </tr>
                                    }
                                </tbody>
                            </table>
                        </div>
                        <div class="d-flex gap-2 align-items-center mt-2">
                            <button class="btn btn-sm btn-outline-secondary" disabled="@(_histOffset == 0)" @onclick="HistPrev">Prev</button>
                            <span class="small text-muted">Page @(_histOffset / _histPageSize + 1)</span>
                            <button class="btn btn-sm btn-outline-secondary" disabled="@(_histEntries.Count < _histPageSize)" @onclick="HistNext">Next</button>
                        </div>
                    }
                </div></div>
                break;
        }

        @if (_result != null)
        {
            <div class="alert alert-success mt-3">
                Transaction broadcast! Tx ID: <span class="mono">@_result</span>
                <div class="mt-1">
                    <a href="https://explorer.qubic.org/network/tx/@_result" target="_blank" rel="noopener" class="me-3">View on Explorer</a>
                    <a href="/history">Transaction History</a>
                </div>
            </div>
        }
        @if (_error != null) { <div class="alert alert-danger mt-2">@_error</div> }
    </div></div>
}

<ConfirmModal Visible="@(_confirmMsg != null)" Title="@(_confirmTitle ?? "Confirm")"
             Message="@(_confirmMsg ?? "")" ConfirmText="@(_confirmBtn ?? "Confirm")"
             OnConfirm="OnConfirmed" OnCancel="OnCancelled" />

@code {
    // Query string parameters for cross-page navigation
    [SupplyParameterFromQuery] public string? Tab { get; set; }
    [SupplyParameterFromQuery] public string? Op { get; set; }
    [SupplyParameterFromQuery(Name = "vault")] public long? QVaultId { get; set; }
    [SupplyParameterFromQuery] public string? Issuer { get; set; }
    [SupplyParameterFromQuery(Name = "asset")] public string? AssetName { get; set; }

    private string[] _tabs = ["Register", "Deposit", "Release", "Assets", "Query"];
    private string _activeTab = "Deposit";
    private bool _hasMsvaultShares;
    private bool _sending;
    private string? _result;
    private string? _error;
    private const int ContractIndex = 11;
    private (ulong register, ulong release, ulong reset, ulong holding, ulong deposit, ulong burn)? _fees;

    // Confirm modal
    private string? _confirmTitle;
    private string? _confirmMsg;
    private string? _confirmBtn;
    private Func<Task>? _confirmAction;

    private void ShowConfirm(string title, string message, string button, Func<Task> action)
    {
        _confirmTitle = title;
        _confirmMsg = message;
        _confirmBtn = button;
        _confirmAction = action;
    }

    private async Task OnConfirmed()
    {
        var action = _confirmAction;
        _confirmMsg = null; _confirmAction = null;
        if (action != null) await action();
    }

    private void OnCancelled()
    {
        _confirmMsg = null; _confirmAction = null;
        _sending = false;
        _pendingApproval = null;
        _pendingAssetApproval = null;
    }

    // Auto-load vaults
    private bool _vaultsLoading;
    private List<VaultSummary>? _vaultSummaries;
    private (ulong vaultId, ulong amount, string dest)? _pendingApproval;
    private (ulong vaultId, string assetName, ulong amount, string dest)? _pendingAssetApproval;

    private record ReleaseRequest(ulong Amount, string Destination, int Approvals, ulong RequiredApprovals,
        string[] ApprovedBy, string[] NotApprovedBy, bool CurrentWalletCanApprove);

    private record AssetBalance(string Issuer, string Name, ulong Balance);

    private record AssetReleaseRequest(string Issuer, string AssetName, ulong Amount, string Destination,
        int Approvals, ulong RequiredApprovals, string[] ApprovedBy, string[] NotApprovedBy, bool CurrentWalletCanApprove);

    private record VaultSummary(ulong Id, string Name, long Balance,
        int OwnerCount, ulong RequiredApprovals, string[] OwnerIdentities,
        List<ReleaseRequest> PendingReleases, List<AssetBalance> AssetBalances,
        List<AssetReleaseRequest> PendingAssetReleases, string? DetailError);

    // Register
    private string _regVaultName = ""; private ulong _regApprovals = 2;
    private List<string> _regOwners = null!;
    // Deposit
    private ulong _depVaultId; private long _depAmount;
    // Release
    private bool _resetMode; private ulong _relVaultId; private string _relDest = ""; private ulong _relAmount;
    // Vote Fee
    private ulong _vfRegFee; private ulong _vfRelFee; private ulong _vfResetFee;
    private ulong _vfHoldFee; private ulong _vfDepFee; private ulong _vfBurnFee;
    // Assets
    private string _assetOp = "deposit"; private ulong _aVaultId;
    private string _aIssuer = ""; private string _aName = ""; private long _aAmount; private string _aDest = "";
    // Query
    private int _queryFunc = 5;
    private string? _qIdentity;
    private ulong _qVaultId;
    private bool _querying;
    private List<KeyValuePair<string, string>>? _queryResult;
    // History
    private bool _histLoading;
    private List<HistoryEntry>? _histEntries;
    private int _histOffset;
    private const int _histPageSize = 50;
    private ulong? _histVaultFilter;

    private record HistoryEntry(
        string Time, uint Tick, string Operation, ulong VaultId,
        int StatusCode, string StatusText, ulong Amount,
        string? Destination, string? Initiator,
        string OpBadgeClass, string StatusBadgeClass,
        bool IsFailure, bool IsPending);

    protected override async Task OnInitializedAsync()
    {
        TxTracker.OnChanged += OnTrackerChanged;

        // Apply query string params for cross-page navigation
        if (!string.IsNullOrEmpty(Tab)) _activeTab = Tab;
        if (!string.IsNullOrEmpty(Op)) _assetOp = Op;
        if (QVaultId.HasValue) _aVaultId = (ulong)QVaultId.Value;
        if (!string.IsNullOrEmpty(Issuer)) _aIssuer = Issuer;
        if (!string.IsNullOrEmpty(AssetName)) _aName = AssetName;

        // Pre-fill first owner with current identity
        var myId = Seed.HasSeed ? Seed.Identity?.ToString() ?? "" : "";
        _regOwners = [myId, ""];

        // Load fees
        try
        {
            var result = await Backend.QuerySmartContractAsync(ContractIndex, 10, []);
            if (result.Length >= 48)
                _fees = (BitConverter.ToUInt64(result, 0), BitConverter.ToUInt64(result, 8),
                         BitConverter.ToUInt64(result, 16), BitConverter.ToUInt64(result, 24),
                         BitConverter.ToUInt64(result, 32), BitConverter.ToUInt64(result, 40));
        }
        catch { }

        // Check if wallet owns MSVault shares (required for Vote Fee)
        if (Seed.HasSeed && Seed.Identity != null)
        {
            try
            {
                var msvaultIssuer = Qubic.Core.QubicContracts.GetContractIdentity(ContractIndex).ToString();
                var assets = await Backend.GetOwnedAssetsAsync(Seed.Identity.Value);
                _hasMsvaultShares = assets.Any(a =>
                    a.Data.IssuedAsset?.IssuerIdentity == msvaultIssuer
                    && long.TryParse(a.Data.NumberOfUnits, out var units) && units > 0);
                if (_hasMsvaultShares)
                    _tabs = ["Register", "Deposit", "Release", "Vote Fee", "Assets", "Query"];
            }
            catch { }
        }

        await LoadVaults();

        // Default vault IDs to first vault (unless already set by query params)
        if (_vaultSummaries is { Count: > 0 })
        {
            var firstId = _vaultSummaries[0].Id;
            if (!QVaultId.HasValue)
            {
                _depVaultId = firstId;
                _relVaultId = firstId;
                _aVaultId = firstId;
            }
        }
    }

    private async Task LoadVaults()
    {
        if (!Seed.HasSeed || Seed.Identity == null) return;
        _vaultsLoading = true;
        StateHasChanged();
        try
        {
            var pk = Seed.Identity.Value.PublicKey;
            var input = new Qubic.Core.Contracts.Msvault.GetVaultsInput { PublicKey = pk }.ToBytes();
            var data = await Backend.QuerySmartContractAsync(ContractIndex, 5, input);
            if (data.Length >= 328)
            {
                var gv = Qubic.Core.Contracts.Msvault.GetVaultsOutput.FromBytes(data);
                var count = (int)Math.Min(gv.NumberOfVaults, 8);
                if (count > 0)
                {
                    var summaries = new List<VaultSummary>();
                    for (int vi = 0; vi < count; vi++)
                    {
                        var vaultId = gv.VaultIds[vi];
                        var name = FormatVaultName(gv.VaultNames[vi]);
                        long balance = 0;
                        int ownerCount = 0;
                        ulong reqApprovals = 0;
                        string[] ownerIdentities = [];
                        var pendingReleases = new List<ReleaseRequest>();
                        var assetBalances = new List<AssetBalance>();
                        var pendingAssetReleases = new List<AssetReleaseRequest>();
                        string? detailError = null;

                        try
                        {
                            var balData = await Backend.QuerySmartContractAsync(ContractIndex, 7,
                                new Qubic.Core.Contracts.Msvault.GetBalanceOfInput { VaultId = vaultId }.ToBytes());
                            if (balData.Length >= 16)
                            {
                                var bo = Qubic.Core.Contracts.Msvault.GetBalanceOfOutput.FromBytes(balData);
                                if (bo.Status == 1) balance = bo.Balance;
                            }

                            var ownData = await Backend.QuerySmartContractAsync(ContractIndex, 11,
                                new Qubic.Core.Contracts.Msvault.GetVaultOwnersInput { VaultId = vaultId }.ToBytes());
                            if (ownData.Length >= 536)
                            {
                                var oo = Qubic.Core.Contracts.Msvault.GetVaultOwnersOutput.FromBytes(ownData);
                                if (oo.Status == 1)
                                {
                                    ownerCount = (int)Math.Min(oo.NumberOfOwners, 16);
                                    reqApprovals = oo.RequiredApprovals;
                                    ownerIdentities = oo.Owners.Take(ownerCount).Select(PkToIdentity).ToArray();
                                }
                                else
                                    detailError = $"Owners query returned status {oo.Status}";
                            }
                            else
                                detailError = $"Owners response too short ({ownData.Length} bytes, expected 536)";

                            var relData = await Backend.QuerySmartContractAsync(ContractIndex, 6,
                                new Qubic.Core.Contracts.Msvault.GetReleaseStatusInput { VaultId = vaultId }.ToBytes());
                            if (relData.Length >= 648)
                            {
                                var ro = Qubic.Core.Contracts.Msvault.GetReleaseStatusOutput.FromBytes(relData);
                                if (ro.Status == 1)
                                {
                                    var myId = Seed.Identity?.ToString() ?? "";
                                    // Group matching (amount, destination) pairs and track which owners approved
                                    var requests = new Dictionary<(ulong amount, string dest), List<string>>();
                                    var ownerRequests = new HashSet<int>(); // owner indices that have a request
                                    for (int oi = 0; oi < ownerCount; oi++)
                                    {
                                        if (ro.Amounts[oi] > 0)
                                        {
                                            ownerRequests.Add(oi);
                                            var dest = PkToIdentity(ro.Destinations[oi]);
                                            var key = (ro.Amounts[oi], dest);
                                            if (!requests.ContainsKey(key)) requests[key] = new();
                                            requests[key].Add(ownerIdentities.Length > oi ? ownerIdentities[oi] : $"Owner #{oi}");
                                        }
                                    }
                                    foreach (var kv in requests)
                                    {
                                        var approved = kv.Value.ToArray();
                                        var notApproved = ownerIdentities.Where(o => !approved.Contains(o)).ToArray();
                                        var canApprove = !string.IsNullOrEmpty(myId)
                                            && ownerIdentities.Contains(myId)
                                            && !approved.Contains(myId);
                                        pendingReleases.Add(new ReleaseRequest(
                                            kv.Key.amount, kv.Key.dest, approved.Length, reqApprovals,
                                            approved, notApproved, canApprove));
                                    }
                                }
                            }
                            // Asset balances (func 22)
                            var abData = await Backend.QuerySmartContractAsync(ContractIndex, 22,
                                new Qubic.Core.Contracts.Msvault.GetVaultAssetBalancesInput { VaultId = vaultId }.ToBytes());
                            if (abData.Length >= 400)
                            {
                                var ab = Qubic.Core.Contracts.Msvault.GetVaultAssetBalancesOutput.FromBytes(abData);
                                if (ab.Status == 1)
                                {
                                    for (int ai = 0; ai < (int)Math.Min(ab.NumberOfAssetTypes, 8); ai++)
                                    {
                                        var e = ab.AssetBalances[ai];
                                        if (e.Balance > 0)
                                        {
                                            var issuer = PkToIdentity(e.Asset.Issuer);
                                            var aName = Qubic.Core.AssetNameHelper.FromUlong(e.Asset.AssetName) ?? "?";
                                            assetBalances.Add(new AssetBalance(issuer, aName, e.Balance));
                                        }
                                    }
                                }
                            }

                            // Asset release status (func 23)
                            var arData = await Backend.QuerySmartContractAsync(ContractIndex, 23,
                                new Qubic.Core.Contracts.Msvault.GetAssetReleaseStatusInput { VaultId = vaultId }.ToBytes());
                            if (arData.Length >= 1288)
                            {
                                var ar = Qubic.Core.Contracts.Msvault.GetAssetReleaseStatusOutput.FromBytes(arData);
                                if (ar.Status == 1)
                                {
                                    var myId2 = Seed.Identity?.ToString() ?? "";
                                    // Group by (asset+amount+dest) to count approvals
                                    var arReqs = new Dictionary<(string issuer, string aname, ulong amount, string dest), List<string>>();
                                    for (int oi = 0; oi < ownerCount; oi++)
                                    {
                                        if (ar.Amounts[oi] > 0)
                                        {
                                            var issuer = PkToIdentity(ar.Assets[oi].Issuer);
                                            var aname = Qubic.Core.AssetNameHelper.FromUlong(ar.Assets[oi].AssetName) ?? "?";
                                            var dest = PkToIdentity(ar.Destinations[oi]);
                                            var key = (issuer, aname, ar.Amounts[oi], dest);
                                            if (!arReqs.ContainsKey(key)) arReqs[key] = new();
                                            arReqs[key].Add(ownerIdentities.Length > oi ? ownerIdentities[oi] : $"Owner #{oi}");
                                        }
                                    }
                                    foreach (var kv in arReqs)
                                    {
                                        var approved = kv.Value.ToArray();
                                        var notApproved = ownerIdentities.Where(o => !approved.Contains(o)).ToArray();
                                        var canApprove = !string.IsNullOrEmpty(myId2)
                                            && ownerIdentities.Contains(myId2)
                                            && !approved.Contains(myId2);
                                        pendingAssetReleases.Add(new AssetReleaseRequest(
                                            kv.Key.issuer, kv.Key.aname, kv.Key.amount, kv.Key.dest,
                                            approved.Length, reqApprovals, approved, notApproved, canApprove));
                                    }
                                }
                            }
                        }
                        catch (Exception ex) { detailError = ex.Message; }

                        summaries.Add(new VaultSummary(vaultId, name, balance,
                            ownerCount, reqApprovals, ownerIdentities, pendingReleases,
                            assetBalances, pendingAssetReleases, detailError));
                    }
                    _vaultSummaries = summaries;
                }
                else
                    _vaultSummaries = null;
            }
        }
        catch { }
        finally { _vaultsLoading = false; }
    }

    private async Task RefreshVaults()
    {
        await LoadVaults();
    }

    private async Task<uint> GetTick() => TickMonitor.IsConnected
        ? TickMonitor.Tick + (uint)Settings.TickOffset
        : (await Backend.GetTickInfoAsync()).Tick + (uint)Settings.TickOffset;

    private async Task Broadcast(long amount, uint tick, Qubic.Core.Payloads.ITransactionPayload payload, string desc)
    {
        var dest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(Qubic.Core.QubicContracts.GetContractPublicKey(ContractIndex));
        var tx = Seed.CreateAndSignTransaction(dest, amount, tick, payload);
        var result = await Backend.BroadcastTransactionAsync(tx);
        _result = result.TransactionId;
        TxTracker.Track(new TrackedTransaction { Hash = result.TransactionId, Source = Seed.Identity?.ToString() ?? "",
            Destination = dest.ToString(), Amount = amount, TargetTick = tick,
            InputType = payload.InputType, PayloadHex = Convert.ToHexString(payload.GetPayloadBytes()), Description = desc,
            RawData = Convert.ToHexString(tx.GetRawBytes()) });
    }

    private void RegisterVault()
    {
        _error = null; _result = null;
        if (_fees == null) { _error = "Fees not loaded yet. Please wait."; return; }
        if (string.IsNullOrWhiteSpace(_regVaultName)) { _error = "Vault name is required."; return; }
        var nameBytes = new byte[32];
        var utf8 = System.Text.Encoding.UTF8.GetBytes(_regVaultName.Trim());
        if (utf8.Length > 32) { _error = "Vault name too long (max 32 bytes UTF-8)."; return; }
        utf8.CopyTo(nameBytes, 0);

        var ownerPks = new List<byte[]>();
        for (int i = 0; i < _regOwners.Count; i++)
        {
            if (string.IsNullOrWhiteSpace(_regOwners[i])) { _error = $"Owner #{i + 1}: identity required."; return; }
            var oe = IdentityValidation.Validate(_regOwners[i]);
            if (oe != null) { _error = $"Owner #{i + 1}: {oe}"; return; }
            ownerPks.Add(Qubic.Core.Entities.QubicIdentity.FromIdentity(_regOwners[i].Trim()).PublicKey);
        }
        if (ownerPks.Count < 2) { _error = "At least 2 owners required."; return; }
        var uniqueSet = new HashSet<string>(ownerPks.Select(Convert.ToHexString));
        if (uniqueSet.Count != ownerPks.Count) { _error = "All owners must be unique identities."; return; }
        if (_regApprovals < 2 || _regApprovals > (ulong)ownerPks.Count)
        { _error = $"Required approvals must be 2-{ownerPks.Count}."; return; }

        ShowConfirm("Register Vault",
            $"Register vault \"{_regVaultName.Trim()}\" with {ownerPks.Count} owners, {_regApprovals} required approvals?\n\nFee: {_fees.Value.register:N0} QU",
            "Register", async () =>
        {
            _sending = true;
            try
            {
                var tick = await GetTick();
                var payload = new Qubic.Core.Contracts.Msvault.RegisterVaultPayload
                {
                    VaultName = nameBytes, Owners = ownerPks.ToArray(), RequiredApprovals = _regApprovals
                };
                await Broadcast((long)_fees!.Value.register, tick, payload,
                    $"MSVault Register: {ownerPks.Count} owners, approvals={_regApprovals}");
            }
            catch (Exception ex) { _error = ex.Message; }
            finally { _sending = false; }
        });
    }

    private void Deposit()
    {
        _error = null; _result = null;
        if (_depAmount <= 0) { _error = "Amount must be positive."; return; }

        var vaultId = _depVaultId; var amount = _depAmount;
        ShowConfirm("Deposit", $"Deposit {amount:N0} QU to vault #{vaultId}?", "Deposit", async () =>
        {
            _sending = true;
            try
            {
                var tick = await GetTick();
                var payload = new Qubic.Core.Contracts.Msvault.DepositPayload { VaultId = vaultId };
                await Broadcast(amount, tick, payload, $"MSVault Deposit: vault {vaultId}, {amount:N0} QU");
            }
            catch (Exception ex) { _error = ex.Message; }
            finally { _sending = false; }
        });
    }

    private void ReleaseOrReset()
    {
        _error = null; _result = null;
        if (_fees == null) { _error = "Fees not loaded yet. Please wait."; return; }
        var vaultId = _relVaultId;
        if (_resetMode)
        {
            var fee = (long)_fees.Value.reset;
            ShowConfirm("Reset Release", $"Reset all pending releases for vault #{vaultId}?\n\nFee: {fee:N0} QU", "Reset", async () =>
            {
                _sending = true;
                try
                {
                    var tick = await GetTick();
                    var payload = new Qubic.Core.Contracts.Msvault.ResetReleasePayload { VaultId = vaultId };
                    await Broadcast(fee, tick, payload, $"MSVault Reset Release: vault {vaultId}");
                }
                catch (Exception ex) { _error = ex.Message; }
                finally { _sending = false; }
            });
        }
        else
        {
            var err = IdentityValidation.Validate(_relDest);
            if (err != null) { _error = $"Destination: {err}"; return; }
            var dest = _relDest.Trim(); var amount = _relAmount; var fee = (long)_fees.Value.release;
            ShowConfirm("Release", $"Release {amount:N0} QU from vault #{vaultId} to {dest[..12]}...?\n\nFee: {fee:N0} QU", "Release", async () =>
            {
                _sending = true;
                try
                {
                    var tick = await GetTick();
                    var payload = new Qubic.Core.Contracts.Msvault.ReleaseToPayload
                    {
                        VaultId = vaultId, Amount = amount,
                        Destination = Qubic.Core.Entities.QubicIdentity.FromIdentity(dest).PublicKey
                    };
                    await Broadcast(fee, tick, payload, $"MSVault Release: vault {vaultId}, {amount:N0} QU");
                }
                catch (Exception ex) { _error = ex.Message; }
                finally { _sending = false; }
            });
        }
    }

    private void VoteFeeChange()
    {
        _error = null; _result = null;
        ShowConfirm("Vote Fee Change",
            $"Vote for new fees?\n\nRegister: {_vfRegFee:N0}\nRelease: {_vfRelFee:N0}\nReset: {_vfResetFee:N0}\nHolding: {_vfHoldFee:N0}\nDeposit: {_vfDepFee:N0}\nBurn: {_vfBurnFee:N0}",
            "Vote", async () =>
        {
            _sending = true;
            try
            {
                var tick = await GetTick();
                var payload = new Qubic.Core.Contracts.Msvault.VoteFeeChangePayload
                {
                    NewRegisteringFee = _vfRegFee, NewReleaseFee = _vfRelFee,
                    NewReleaseResetFee = _vfResetFee, NewHoldingFee = _vfHoldFee,
                    NewDepositFee = _vfDepFee, BurnFee = _vfBurnFee
                };
                await Broadcast(0, tick, payload, "MSVault Vote Fee Change");
            }
            catch (Exception ex) { _error = ex.Message; }
            finally { _sending = false; }
        });
    }

    private Qubic.Core.Contracts.QubicAsset ParseAsset()
    {
        var issuerPk = Qubic.Core.Entities.QubicIdentity.FromIdentity(_aIssuer.Trim()).PublicKey;
        var assetName = AssetNameHelper.ToUlong(_aName.Trim());
        return new Qubic.Core.Contracts.QubicAsset { Issuer = issuerPk, AssetName = assetName };
    }

    private async Task AssetOp()
    {
        _error = null; _result = null;
        if (_fees == null) { _error = "Fees not loaded yet. Please wait."; return; }

        var err = IdentityValidation.Validate(_aIssuer);
        if (err != null) { _error = $"Asset Issuer: {err}"; return; }
        if (string.IsNullOrWhiteSpace(_aName)) { _error = "Asset name required."; return; }
        if (_assetOp == "release")
        {
            var re = IdentityValidation.Validate(_aDest);
            if (re != null) { _error = $"Destination: {re}"; return; }
        }

        // For deposit, look up the current managing contract to decide if rights transfer is needed
        int managingContract = Qubic.Core.QubicContracts.Qx; // default
        ulong rightsFee = 0;
        bool transferRights = false;
        if (_assetOp == "deposit" && Seed.HasSeed && Seed.Identity != null)
        {
            try
            {
                var assets = await Backend.GetOwnedAssetsAsync(Seed.Identity.Value);
                var match = assets.FirstOrDefault(a =>
                    a.Data.IssuedAsset?.IssuerIdentity == _aIssuer.Trim()
                    && a.Data.IssuedAsset?.Name == _aName.Trim());
                if (match != null)
                {
                    managingContract = (int)match.Data.ManagingContractIndex;
                    if (managingContract == ContractIndex)
                    {
                        // Already managed by MSVault — no transfer needed
                        transferRights = false;
                    }
                    else if (!Qubic.Core.QubicContracts.SupportsManagementRightsTransfer(managingContract))
                    {
                        _error = $"Asset is managed by {Qubic.Core.QubicContracts.FormatContract(managingContract)} which does not support rights transfer.";
                        return;
                    }
                    else
                    {
                        // Rights need to be transferred — do it automatically
                        transferRights = true;
                        rightsFee = StaticData.GetContractFee(managingContract, "Transfer Share Management Rights") ?? 0;
                    }
                }
                else
                {
                    _error = "Asset not found in your owned assets. Make sure you own the specified asset.";
                    return;
                }
            }
            catch (Exception ex)
            {
                _error = $"Failed to look up asset: {ex.Message}";
                return;
            }
        }

        string confirmMsg = _assetOp switch
        {
            "deposit" when transferRights => $"Deposit {_aAmount:N0} {_aName.Trim()} to vault #{_aVaultId}?\n\nThis will send 2 transactions:\n1. Transfer management rights from {Qubic.Core.QubicContracts.FormatContract(managingContract)} to MSVault{(rightsFee > 0 ? $" (fee: {rightsFee:N0} QU)" : "")}\n2. Deposit asset to vault (fee: {_fees.Value.deposit:N0} QU)",
            "deposit" => $"Deposit {_aAmount:N0} {_aName.Trim()} to vault #{_aVaultId}?\n\nFee: {_fees.Value.deposit:N0} QU",
            "release" => $"Release {_aAmount:N0} {_aName.Trim()} from vault #{_aVaultId} to {_aDest.Trim()[..Math.Min(12, _aDest.Trim().Length)]}...?\n\nFee: {_fees.Value.release:N0} QU",
            "reset" => $"Reset all pending asset releases for vault #{_aVaultId}?\n\nFee: {_fees.Value.reset:N0} QU",
            "revoke" => $"Revoke management rights for {_aAmount:N0} {_aName.Trim()} shares?\n\nFee: 100 QU",
            _ => "Proceed with asset operation?"
        };
        string title = _assetOp switch
        {
            "deposit" => "Deposit Asset",
            "release" => "Release Asset",
            "reset" => "Reset Asset Release",
            "revoke" => "Revoke Management Rights",
            _ => "Asset Operation"
        };
        var asset = ParseAsset();
        var op = _assetOp;
        var vaultId = _aVaultId;
        var amount = (ulong)_aAmount;
        var name = _aName.Trim();
        var dest = _assetOp == "release" ? _aDest.Trim() : "";
        var doTransferRights = transferRights;
        var mgmtContract = managingContract;
        var mgmtFee = rightsFee;
        var depositFee = (long)_fees.Value.deposit;
        var releaseFee = (long)_fees.Value.release;
        var resetFee = (long)_fees.Value.reset;
        const long revokeFee = 100;

        ShowConfirm(title, confirmMsg, "Confirm", async () =>
        {
            _sending = true;
            try
            {
                var tick = await GetTick();
                switch (op)
                {
                    case "deposit":
                        if (doTransferRights)
                        {
                            // Step 1: Transfer management rights to MSVault
                            var rightsPayload = Qubic.Core.QubicContracts.CreateManagementRightsPayload(
                                mgmtContract, asset, (long)amount, ContractIndex);
                            var rightsDest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(
                                Qubic.Core.QubicContracts.GetContractPublicKey(mgmtContract));
                            var rightsTx = Seed.CreateAndSignTransaction(rightsDest, (long)mgmtFee, tick, rightsPayload);
                            var rightsResult = await Backend.BroadcastTransactionAsync(rightsTx);
                            TxTracker.Track(new TrackedTransaction
                            {
                                Hash = rightsResult.TransactionId, Source = Seed.Identity?.ToString() ?? "",
                                Destination = rightsDest.ToString(), Amount = (long)mgmtFee, TargetTick = tick,
                                InputType = rightsPayload.InputType,
                                PayloadHex = Convert.ToHexString(rightsPayload.GetPayloadBytes()),
                                Description = $"Transfer Rights {name} x{amount} → MSVault",
                                RawData = Convert.ToHexString(rightsTx.GetRawBytes())
                            });
                            // Step 2: Deposit at a later tick so rights transfer executes first
                            tick += 1;
                        }
                        var dp = new Qubic.Core.Contracts.Msvault.DepositAssetPayload { VaultId = vaultId, Asset = asset, Amount = amount };
                        await Broadcast(depositFee, tick, dp, $"MSVault Deposit Asset: vault {vaultId}, {name} x{amount}");
                        break;
                    case "release":
                        var rp = new Qubic.Core.Contracts.Msvault.ReleaseAssetToPayload
                        {
                            VaultId = vaultId, Asset = asset, Amount = amount,
                            Destination = Qubic.Core.Entities.QubicIdentity.FromIdentity(dest).PublicKey
                        };
                        await Broadcast(releaseFee, tick, rp, $"MSVault Release Asset: vault {vaultId}, {name} x{amount}");
                        break;
                    case "reset":
                        var rap = new Qubic.Core.Contracts.Msvault.ResetAssetReleasePayload { VaultId = vaultId };
                        await Broadcast(resetFee, tick, rap, $"MSVault Reset Asset Release: vault {vaultId}");
                        break;
                    case "revoke":
                        var rvp = new Qubic.Core.Contracts.Msvault.RevokeAssetManagementRightsPayload { Asset = asset, NumberOfShares = (long)amount };
                        await Broadcast(revokeFee, tick, rvp, $"MSVault Revoke Mgmt Rights: {name} x{amount}");
                        break;
                }
            }
            catch (Exception ex) { _error = ex.Message; }
            finally { _sending = false; }
        });
    }

    private byte[] GetQueryPk()
    {
        var err = IdentityValidation.Validate(_qIdentity);
        if (err != null) throw new Exception("Identity: " + err);
        return Qubic.Core.Entities.QubicIdentity.FromIdentity(_qIdentity!.Trim()).PublicKey;
    }

    private string PkToIdentity(byte[] pk)
    {
        try { return Qubic.Core.Entities.QubicIdentity.FromPublicKey(pk).ToString(); }
        catch { return Convert.ToHexString(pk); }
    }

    /// <summary>Display a 32-byte vault name: try UTF-8 text first, then identity, then hex.</summary>
    private string FormatVaultName(byte[] raw)
    {
        if (raw == null || raw.Length == 0) return "(empty)";
        // Try UTF-8: trim trailing nulls, check if all bytes are valid printable UTF-8
        var trimmed = raw.AsSpan().TrimEnd((byte)0);
        if (trimmed.Length > 0)
        {
            try
            {
                var text = System.Text.Encoding.UTF8.GetString(trimmed);
                // Accept if all characters are printable (not control chars except space)
                if (text.Length > 0 && !text.Any(c => char.IsControl(c) && c != '\t'))
                    return text;
            }
            catch { }
        }
        // Fall back to identity format or hex
        return PkToIdentity(raw);
    }

    private void GoToDeposit(ulong vaultId) { _depVaultId = vaultId; _activeTab = "Deposit"; }
    private void GoToRelease(ulong vaultId) { _relVaultId = vaultId; _resetMode = false; _activeTab = "Release"; }
    private void GoToReset(ulong vaultId) { _relVaultId = vaultId; _resetMode = true; _activeTab = "Release"; }
    private void GoToAssetDeposit(ulong vaultId) { _aVaultId = vaultId; _assetOp = "deposit"; _activeTab = "Assets"; }
    private void GoToAssetRelease(ulong vaultId) { _aVaultId = vaultId; _assetOp = "release"; _activeTab = "Assets"; }
    private void GoToAssetRelease(ulong vaultId, string issuer, string name)
    {
        _aVaultId = vaultId; _aIssuer = issuer; _aName = name;
        _assetOp = "release"; _activeTab = "Assets";
    }

    private void ApproveRelease(ulong vaultId, ulong amount, string destination)
    {
        if (_fees == null) { _error = "Fees not loaded yet. Please wait."; return; }
        _error = null; _result = null;
        var fee = (long)_fees.Value.release;
        ShowConfirm("Approve Release",
            $"Approve release of {amount:N0} QU from vault #{vaultId} to {destination[..Math.Min(12, destination.Length)]}...?\n\nFee: {fee:N0} QU",
            "Approve", async () =>
        {
            _sending = true;
            _pendingApproval = (vaultId, amount, destination);
            StateHasChanged();
            try
            {
                var tick = await GetTick();
                var payload = new Qubic.Core.Contracts.Msvault.ReleaseToPayload
                {
                    VaultId = vaultId, Amount = amount,
                    Destination = Qubic.Core.Entities.QubicIdentity.FromIdentity(destination).PublicKey
                };
                await Broadcast(fee, tick, payload, $"MSVault Approve Release: vault {vaultId}, {amount:N0} QU");
                await LoadVaults();
            }
            catch (Exception ex) { _error = ex.Message; }
            finally { _sending = false; _pendingApproval = null; }
        });
    }

    private void ApproveAssetRelease(ulong vaultId, string issuer, string assetName, ulong amount, string destination)
    {
        if (_fees == null) { _error = "Fees not loaded yet. Please wait."; return; }
        _error = null; _result = null;
        var fee = (long)_fees.Value.release;
        ShowConfirm("Approve Asset Release",
            $"Approve release of {amount:N0} {assetName} from vault #{vaultId} to {destination[..Math.Min(12, destination.Length)]}...?\n\nFee: {fee:N0} QU",
            "Approve", async () =>
        {
            _sending = true;
            _pendingAssetApproval = (vaultId, assetName, amount, destination);
            StateHasChanged();
            try
            {
                var tick = await GetTick();
                var asset = new Qubic.Core.Contracts.QubicAsset
                {
                    Issuer = Qubic.Core.Entities.QubicIdentity.FromIdentity(issuer).PublicKey,
                    AssetName = Qubic.Core.AssetNameHelper.ToUlong(assetName)
                };
                var payload = new Qubic.Core.Contracts.Msvault.ReleaseAssetToPayload
                {
                    VaultId = vaultId, Asset = asset, Amount = amount,
                    Destination = Qubic.Core.Entities.QubicIdentity.FromIdentity(destination).PublicKey
                };
                await Broadcast(fee, tick, payload, $"MSVault Approve Asset Release: vault {vaultId}, {assetName} x{amount}");
                await LoadVaults();
            }
            catch (Exception ex) { _error = ex.Message; }
            finally { _sending = false; _pendingAssetApproval = null; }
        });
    }

    private async Task RunQuery()
    {
        _querying = true; _error = null; _queryResult = null;
        try
        {
            byte[] input;
            switch (_queryFunc)
            {
                case 5: input = new Qubic.Core.Contracts.Msvault.GetVaultsInput { PublicKey = GetQueryPk() }.ToBytes(); break;
                case 6: input = new Qubic.Core.Contracts.Msvault.GetReleaseStatusInput { VaultId = _qVaultId }.ToBytes(); break;
                case 7: input = new Qubic.Core.Contracts.Msvault.GetBalanceOfInput { VaultId = _qVaultId }.ToBytes(); break;
                case 8: input = new Qubic.Core.Contracts.Msvault.GetVaultNameInput { VaultId = _qVaultId }.ToBytes(); break;
                case 10: input = []; break;
                case 11: input = new Qubic.Core.Contracts.Msvault.GetVaultOwnersInput { VaultId = _qVaultId }.ToBytes(); break;
                case 12: input = new Qubic.Core.Contracts.Msvault.IsShareHolderInput { Candidate = GetQueryPk() }.ToBytes(); break;
                default: return;
            }

            var result = await Backend.QuerySmartContractAsync(ContractIndex, (uint)_queryFunc, input);
            _queryResult = ParseMsvaultResult(_queryFunc, result);
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _querying = false; }
    }

    private List<KeyValuePair<string, string>> ParseMsvaultResult(int func, byte[] data)
    {
        var list = new List<KeyValuePair<string, string>>();
        switch (func)
        {
            case 5 when data.Length >= 328: // GetVaults
                var gv = Qubic.Core.Contracts.Msvault.GetVaultsOutput.FromBytes(data);
                list.Add(new("Number of Vaults", gv.NumberOfVaults.ToString()));
                for (int i = 0; i < (int)Math.Min(gv.NumberOfVaults, 8); i++)
                {
                    list.Add(new($"Vault ID #{i + 1}", gv.VaultIds[i].ToString()));
                    list.Add(new($"Vault Name #{i + 1}", FormatVaultName(gv.VaultNames[i])));
                }
                break;

            case 6 when data.Length >= 648: // GetReleaseStatus
                var rs = Qubic.Core.Contracts.Msvault.GetReleaseStatusOutput.FromBytes(data);
                list.Add(new("Status", rs.Status.ToString()));
                for (int i = 0; i < 16; i++)
                {
                    if (rs.Amounts[i] > 0)
                        list.Add(new($"Release #{i + 1}", $"{rs.Amounts[i]:N0} QU → {PkToIdentity(rs.Destinations[i])}"));
                }
                break;

            case 7 when data.Length >= 16: // GetBalanceOf
                var bo = Qubic.Core.Contracts.Msvault.GetBalanceOfOutput.FromBytes(data);
                list.Add(new("Status", bo.Status.ToString()));
                list.Add(new("Balance", bo.Balance.ToString("N0")));
                break;

            case 8 when data.Length >= 40: // GetVaultName
                var vn = Qubic.Core.Contracts.Msvault.GetVaultNameOutput.FromBytes(data);
                list.Add(new("Status", vn.Status.ToString()));
                list.Add(new("Vault Name", FormatVaultName(vn.VaultName)));
                break;

            case 10 when data.Length >= 48: // GetFees
                var fees = Qubic.Core.Contracts.Msvault.GetFeesOutput.FromBytes(data);
                list.Add(new("Registering Fee", fees.RegisteringFee.ToString("N0")));
                list.Add(new("Release Fee", fees.ReleaseFee.ToString("N0")));
                list.Add(new("Release Reset Fee", fees.ReleaseResetFee.ToString("N0")));
                list.Add(new("Holding Fee", fees.HoldingFee.ToString("N0")));
                list.Add(new("Deposit Fee", fees.DepositFee.ToString("N0")));
                list.Add(new("Burn Fee", fees.BurnFee.ToString("N0")));
                break;

            case 11 when data.Length >= 536: // GetVaultOwners
                var vo = Qubic.Core.Contracts.Msvault.GetVaultOwnersOutput.FromBytes(data);
                list.Add(new("Status", vo.Status.ToString()));
                list.Add(new("Number of Owners", vo.NumberOfOwners.ToString()));
                for (int i = 0; i < (int)Math.Min(vo.NumberOfOwners, 16); i++)
                    list.Add(new($"Owner #{i + 1}", PkToIdentity(vo.Owners[i])));
                list.Add(new("Required Approvals", vo.RequiredApprovals.ToString()));
                break;

            case 12 when data.Length >= 8: // IsShareHolder
                var sh = Qubic.Core.Contracts.Msvault.IsShareHolderOutput.FromBytes(data);
                list.Add(new("Result", sh.Result != 0 ? "Yes (shareholder)" : "No"));
                list.Add(new("Raw Value", sh.Result.ToString()));
                break;

            default:
                list.Add(new("Result", data.Length > 0 ? Convert.ToHexString(data) : "(empty)"));
                break;
        }
        return list;
    }

    // ── History ──

    private void LoadHistory()
    {
        if (!WalletStorage.IsOpen) return;
        _histLoading = true;
        StateHasChanged();
        try
        {
            // Query contract INFO logs (log_type=6) for MSVault (contractIndex=11)
            var logs = WalletStorage.GetLogEvents(new Qubic.Services.Storage.LogEventQuery
            {
                LogType = 6, ContractIndex = ContractIndex,
                Offset = _histOffset, Limit = _histPageSize
            });
            _histEntries = logs.Select(ParseHistoryLog).Where(e => e != null
                && (!_histVaultFilter.HasValue || e.VaultId == _histVaultFilter.Value)).ToList()!;
        }
        catch { _histEntries = null; }
        finally { _histLoading = false; }
    }

    private void HistPrev() { _histOffset = Math.Max(0, _histOffset - _histPageSize); LoadHistory(); }
    private void HistNext() { _histOffset += _histPageSize; LoadHistory(); }

    private void FilterHistoryByVault(ulong vaultId) { _histVaultFilter = vaultId; _histOffset = 0; LoadHistory(); }

    private HistoryEntry? ParseHistoryLog(Qubic.Services.Storage.StoredLogEvent log)
    {
        if (string.IsNullOrEmpty(log.Body)) return null;
        try
        {
            using var doc = System.Text.Json.JsonDocument.Parse(log.Body);
            var root = doc.RootElement;
            var ci = GetJsonLong(root, "_contractIndex");
            if (ci != ContractIndex) return null;

            var statusCode = (int)GetJsonLong(root, "_type");
            var vaultId = (ulong)GetJsonLong(root, "vaultId");
            var amount = (ulong)GetJsonLong(root, "amount");
            var ownerIdStr = GetJsonStr(root, "ownerID");
            var destStr = GetJsonStr(root, "destination");

            // Determine operation from linked transaction InputType
            string op = "Unknown";
            if (!string.IsNullOrEmpty(log.TxHash))
            {
                var txs = WalletStorage.GetTransactions(new Qubic.Services.Storage.TransactionQuery
                {
                    SearchHash = log.TxHash, Limit = 1
                });
                if (txs.Count > 0)
                    op = MsvaultInputTypeName(txs[0].InputType);
            }
            // Fallback: infer from fields if tx not found
            if (op == "Unknown")
                op = InferOperation(statusCode, amount, destStr, vaultId);

            var statusText = MsvaultStatusName(statusCode);
            bool isFailure = statusCode >= 2 && statusCode <= 8;
            bool isPending = statusCode == 9;

            var opBadge = op switch
            {
                "Register" => "bg-info text-dark",
                "Deposit" or "Deposit Asset" => "bg-primary",
                "Release" or "Release Asset" => "bg-warning text-dark",
                "Reset Release" or "Reset Asset Release" => "bg-secondary",
                "Vote Fee" => "bg-dark",
                "Revoke Mgmt Rights" => "bg-danger",
                _ => "bg-secondary"
            };
            var statusBadge = statusCode switch
            {
                1 => "bg-success",
                9 => "bg-warning text-dark",
                _ when isFailure => "bg-danger",
                _ => "bg-secondary"
            };

            var time = FormatLogTimestamp(log.Timestamp);

            // Null-ID destination is all 'A's (identity of zero public key)
            if (destStr != null && destStr.All(c => c == 'A'))
                destStr = null;

            return new HistoryEntry(time, log.Tick, op, vaultId, statusCode, statusText,
                amount, destStr, ownerIdStr, opBadge, statusBadge, isFailure, isPending);
        }
        catch { return null; }
    }

    private static string MsvaultInputTypeName(uint inputType) => inputType switch
    {
        1 => "Register",
        2 => "Deposit",
        3 => "Release",
        4 => "Reset Release",
        13 => "Vote Fee",
        19 => "Deposit Asset",
        20 => "Release Asset",
        21 => "Reset Asset Release",
        25 => "Revoke Mgmt Rights",
        _ => "Unknown"
    };

    private static string InferOperation(int status, ulong amount, string? dest, ulong vaultId)
    {
        if (status == 9) return amount > 0 ? "Release" : "Release Asset"; // PENDING_APPROVAL
        if (amount > 0 && !string.IsNullOrEmpty(dest) && !dest.All(c => c == 'A')) return "Release";
        if (amount > 0) return "Deposit";
        if (vaultId > 0) return "Register";
        return "Unknown";
    }

    private static string MsvaultStatusName(int code) => code switch
    {
        0 => "Failure",
        1 => "Success",
        2 => "Insufficient Fee",
        3 => "Invalid Vault",
        4 => "Not Authorized",
        5 => "Invalid Params",
        6 => "Insufficient Balance",
        7 => "Limit Reached",
        8 => "Transfer Failed",
        9 => "Pending Approval",
        _ => $"Code {code}"
    };

    private static long GetJsonLong(System.Text.Json.JsonElement root, string name)
    {
        if (!root.TryGetProperty(name, out var prop)) return 0;
        if (prop.ValueKind == System.Text.Json.JsonValueKind.Number && prop.TryGetInt64(out var v)) return v;
        if (prop.ValueKind == System.Text.Json.JsonValueKind.String && long.TryParse(prop.GetString(), out var sv)) return sv;
        return 0;
    }

    private static string? GetJsonStr(System.Text.Json.JsonElement root, string name)
    {
        if (root.TryGetProperty(name, out var prop) && prop.ValueKind == System.Text.Json.JsonValueKind.String)
            return prop.GetString();
        return null;
    }

    private static string FormatLogTimestamp(string? timestamp)
    {
        if (string.IsNullOrEmpty(timestamp)) return "—";
        if (long.TryParse(timestamp, out var epoch))
        {
            var dto = epoch > 1_000_000_000_000
                ? DateTimeOffset.FromUnixTimeMilliseconds(epoch)
                : DateTimeOffset.FromUnixTimeSeconds(epoch);
            return dto.LocalDateTime.ToString("yyyy-MM-dd HH:mm");
        }
        if (DateTimeOffset.TryParse(timestamp, out var parsed))
            return parsed.LocalDateTime.ToString("yyyy-MM-dd HH:mm");
        return timestamp;
    }

    private bool _disposed;
    private readonly HashSet<string> _pendingReleaseTxHashes = [];

    private void OnTrackerChanged()
    {
        if (_disposed) return;
        InvokeAsync(async () =>
        {
            if (_disposed) return;

            // Check if any previously-pending release tx just confirmed
            if (_pendingReleaseTxHashes.Count > 0)
            {
                var confirmed = TxTracker.Transactions
                    .Where(t => _pendingReleaseTxHashes.Contains(t.Hash)
                                && t.Status is TrackedTxStatus.Confirmed or TrackedTxStatus.Failed or TrackedTxStatus.Unknown)
                    .Select(t => t.Hash).ToList();

                if (confirmed.Count > 0)
                {
                    foreach (var h in confirmed) _pendingReleaseTxHashes.Remove(h);
                    StateHasChanged();
                    // Reload vaults after a short delay to let on-chain state settle
                    await Task.Delay(2000);
                    if (!_disposed) await LoadVaults();
                }
            }

            // Track currently pending release txs
            foreach (var t in TxTracker.Transactions)
            {
                if (t.Status == TrackedTxStatus.Pending
                    && t.Description.Contains("Release", StringComparison.Ordinal)
                    && t.Description.Contains("vault ", StringComparison.Ordinal))
                {
                    _pendingReleaseTxHashes.Add(t.Hash);
                }
            }

            if (!_disposed) StateHasChanged();
        });
    }

    private bool HasPendingReleaseTx(ulong vaultId)
    {
        var marker = $"vault {vaultId},";
        return TxTracker.Transactions.Any(t =>
            t.Status == TrackedTxStatus.Pending
            && t.Description.Contains(marker, StringComparison.Ordinal)
            && t.Description.Contains("Release", StringComparison.Ordinal));
    }

    public void Dispose()
    {
        _disposed = true;
        TxTracker.OnChanged -= OnTrackerChanged;
    }
}
