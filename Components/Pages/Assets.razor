@page "/assets"
@implements IDisposable
@inject QubicBackendService Backend
@inject SeedSessionService Seed
@inject TickMonitorService TickMonitor
@inject TransactionTrackerService TxTracker
@inject QubicSettingsService Settings
@inject QubicStaticService StaticData
@inject NavigationManager Nav
@inject VaultService Vault

<h4>Asset Portfolio</h4>
<p class="text-muted">View owned, issued, and possessed assets for any identity. Transfer assets and change management rights.</p>

<div class="row mb-3">
    <div class="col-md-10">
        <div class="d-flex gap-2 mb-1">
            <div class="flex-grow-1">
                <AddressInput @bind-Value="_identity" Placeholder="Enter 60-character identity" />
            </div>
            <button class="btn btn-sm btn-primary" @onclick="Lookup" disabled="@(_loading || IdentityValidation.Validate(_identity) != null)">
                @(_loading ? "Loading..." : "Lookup Assets")
            </button>
        </div>
        @{ var idErr = IdentityValidation.Validate(_identity); }
        @if (idErr != null)
        {
            <div class="small text-danger">@idErr</div>
        }
    </div>
</div>

@if (_error != null)
{
    <div class="alert alert-danger">@_error</div>
}

@* ── Open Orders ── *@
@if (_ordersLoading)
{
    <div class="text-muted mb-3"><span class="spinner-border spinner-border-sm me-1"></span> Loading open orders...</div>
}
else if ((_myAskOrders != null && _myAskOrders.Count > 0) || (_myBidOrders != null && _myBidOrders.Count > 0))
{
    var orderCount = (_myAskOrders?.Count ?? 0) + (_myBidOrders?.Count ?? 0);
    <div class="card mb-3 border-info">
        <div class="card-header card-header-accent">Your Open QX Orders (@orderCount)</div>
        <div class="card-body">
            <div class="table-responsive">
                <table class="table table-sm table-hover mb-0">
                    <thead><tr><th>Type</th><th>Asset</th><th>Price</th><th>Shares</th><th></th></tr></thead>
                    <tbody>
                        @if (_myAskOrders != null)
                        {
                            @foreach (var o in _myAskOrders)
                            {
                                var order = o;
                                var key = $"a:{o.AssetName}:{o.Price}:{o.NumberOfShares}";
                                var isCancelling = IsCancelPending(key);
                                <tr>
                                    <td><span class="badge bg-danger">Ask</span></td>
                                    <td class="mono">@(Qubic.Core.AssetNameHelper.FromUlong(o.AssetName) ?? "?")</td>
                                    <td class="mono">@o.Price.ToString("N0")</td>
                                    <td class="mono">@o.NumberOfShares.ToString("N0")</td>
                                    <td>
                                        <button class="btn btn-sm btn-outline-danger" @onclick="() => CancelAskOrder(order, key)" disabled="@(isCancelling || _pendingCancels.Count > 0)">
                                            @if (isCancelling) { <span class="spinner-border spinner-border-sm me-1"></span> } Cancel
                                        </button>
                                    </td>
                                </tr>
                            }
                        }
                        @if (_myBidOrders != null)
                        {
                            @foreach (var o in _myBidOrders)
                            {
                                var order = o;
                                var key = $"b:{o.AssetName}:{o.Price}:{o.NumberOfShares}";
                                var isCancelling = IsCancelPending(key);
                                <tr>
                                    <td><span class="badge bg-success">Bid</span></td>
                                    <td class="mono">@(Qubic.Core.AssetNameHelper.FromUlong(o.AssetName) ?? "?")</td>
                                    <td class="mono">@o.Price.ToString("N0")</td>
                                    <td class="mono">@o.NumberOfShares.ToString("N0")</td>
                                    <td>
                                        <button class="btn btn-sm btn-outline-danger" @onclick="() => CancelBidOrder(order, key)" disabled="@(isCancelling || _pendingCancels.Count > 0)">
                                            @if (isCancelling) { <span class="spinner-border spinner-border-sm me-1"></span> } Cancel
                                        </button>
                                    </td>
                                </tr>
                            }
                        }
                    </tbody>
                </table>
            </div>
        </div>
    </div>
}

@if (_owned != null)
{
    <div class="card mb-3">
        @{ var ownedVisible = _owned.Where(a => long.TryParse(a.Data.NumberOfUnits, out var u) ? u > 0 : true).ToList(); }
        <div class="card-header">Owned Assets (@ownedVisible.Count)</div>
        <div class="card-body">
            @if (ownedVisible.Count == 0)
            {
                <span class="text-muted">No owned assets.</span>
            }
            else
            {
                <div class="table-responsive">
                    <table class="table table-sm table-hover">
                        <thead>
                            <tr>
                                <th>Asset</th>
                                <th>Units</th>
                                <th>Contract</th>
                                @if (Seed.HasSeed)
                                {
                                    <th>Actions</th>
                                }
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var a in ownedVisible)
                            {
                                var assetName = a.Data.IssuedAsset?.Name ?? "?";
                                var issuerIdentity = a.Data.IssuedAsset?.IssuerIdentity ?? "";
                                var poolKey = $"{issuerIdentity}:{assetName}";
                                <tr>
                                    <td class="mono">
                                        @assetName
                                        @if (_qswapPools != null && _qswapPools.ContainsKey(poolKey))
                                        {
                                            <span class="badge bg-info ms-1" title="QSwap pool available (QU: @(_qswapPools[poolKey].quReserve.ToString("N0")) | Asset: @(_qswapPools[poolKey].assetReserve.ToString("N0")))">QSwap</span>
                                        }
                                    </td>
                                    <td class="mono">@a.Data.NumberOfUnits</td>
                                    <td>@Qubic.Core.QubicContracts.FormatContract((int)a.Data.ManagingContractIndex)</td>
                                    @if (Seed.HasSeed)
                                    {
                                        var units = long.Parse(a.Data.NumberOfUnits);
                                        var isQx = a.Data.ManagingContractIndex == QxContractIndex;
                                        <td>
                                            @if (isQx)
                                            {
                                                <button class="btn btn-sm btn-outline-info me-1"
                                                        @onclick="() => OpenOrderBook(assetName, issuerIdentity)">Orders</button>
                                                <button class="btn btn-sm btn-outline-success me-1"
                                                        @onclick="() => OpenAsk(assetName, issuerIdentity, units)">Sell</button>
                                                <button class="btn btn-sm btn-outline-warning me-1"
                                                        @onclick="() => OpenBid(assetName, issuerIdentity, units)">Buy</button>
                                            }
                                            <button class="btn btn-sm btn-outline-primary me-1"
                                                    @onclick="() => OpenTransfer(assetName, issuerIdentity, units)">Transfer</button>
                                            <button class="btn btn-sm btn-outline-secondary me-1"
                                                    @onclick="() => OpenRights(assetName, issuerIdentity, units, (int)a.Data.ManagingContractIndex)">Rights</button>
                                            <button class="btn btn-sm btn-outline-info"
                                                    @onclick="() => OpenVaultDeposit(assetName, issuerIdentity)"
                                                    title="Deposit to MSVault">MSVAULT</button>
                                        </td>
                                    }
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            }
        </div>
    </div>
}

@if (_possessed != null)
{
    var possessedVisible = _possessed.Where(a => long.TryParse(a.Data.NumberOfUnits, out var u) ? u > 0 : true).ToList();
    <div class="card mb-3">
        <div class="card-header">Possessed Assets (@possessedVisible.Count)</div>
        <div class="card-body">
            @if (possessedVisible.Count == 0)
            {
                <span class="text-muted">No possessed assets.</span>
            }
            else
            {
                <div class="table-responsive">
                    <table class="table table-sm table-hover">
                        <thead>
                            <tr>
                                <th>Asset</th>
                                <th>Units</th>
                                <th>Possessor</th>
                                <th>Contract</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var a in possessedVisible)
                            {
                                <tr>
                                    <td class="mono">@(a.Data.OwnedAsset?.IssuedAsset?.Name ?? "?")</td>
                                    <td class="mono">@a.Data.NumberOfUnits</td>
                                    <td><AddressDisplay Address="@a.Data.PossessorIdentity" /></td>
                                    <td>@Qubic.Core.QubicContracts.FormatContract((int)a.Data.ManagingContractIndex)</td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            }
        </div>
    </div>
}

@if (_issued != null)
{
    <div class="card mb-3">
        <div class="card-header">Issued Assets (@_issued.Count)</div>
        <div class="card-body">
            @if (_issued.Count == 0)
            {
                <span class="text-muted">No issued assets.</span>
            }
            else
            {
                <div class="table-responsive">
                    <table class="table table-sm table-hover">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Issuer</th>
                                <th>Type</th>
                                <th>Decimals</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var a in _issued)
                            {
                                <tr>
                                    <td class="mono">@a.Data.Name</td>
                                    <td><AddressDisplay Address="@a.Data.IssuerIdentity" /></td>
                                    <td>@a.Data.Type</td>
                                    <td>@a.Data.NumberOfDecimalPlaces</td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            }
        </div>
    </div>
}

@* ── Action Modal ── *@
@if (_actionMode != ActionMode.None && Seed.HasSeed)
{
    <div class="modal d-block" tabindex="-1" style="background:rgba(0,0,0,0.5)" @onclick="CloseAction">
        <div class="modal-dialog modal-lg" @onclick:stopPropagation>
            <div class="modal-content">
                <div class="modal-header card-header-accent">
                    <h5 class="modal-title">@GetModalTitle() — @_actionAssetName</h5>
                    <button type="button" class="btn-close" @onclick="CloseAction"></button>
                </div>
                <div class="modal-body">
                    @if (_actionMode == ActionMode.OrderBook)
                    {
                        @if (_bookLoading)
                        {
                            <div class="text-muted"><span class="spinner-border spinner-border-sm me-1"></span> Loading order book...</div>
                        }
                        else
                        {
                            <div class="small text-muted mb-2">Click a row to pre-fill a buy or sell order.</div>
                            <div class="row">
                                <div class="col-md-6">
                                    <h6 class="text-danger">Asks (Sellers)</h6>
                                    @if (_bookAsks != null && _bookAsks.Count > 0)
                                    {
                                        <table class="table table-sm table-hover mb-0">
                                            <thead><tr><th>Price</th><th>Shares</th></tr></thead>
                                            <tbody>
                                                @foreach (var o in _bookAsks.OrderBy(o => o.Price))
                                                {
                                                    var ask = o;
                                                    <tr role="button" @onclick="() => FillBidFromAsk(ask)" title="Buy at this price">
                                                        <td class="mono">@o.Price.ToString("N0")</td><td class="mono">@o.NumberOfShares.ToString("N0")</td>
                                                    </tr>
                                                }
                                            </tbody>
                                        </table>
                                    }
                                    else { <span class="text-muted small">No asks.</span> }
                                </div>
                                <div class="col-md-6">
                                    <h6 class="text-success">Bids (Buyers)</h6>
                                    @if (_bookBids != null && _bookBids.Count > 0)
                                    {
                                        <table class="table table-sm table-hover mb-0">
                                            <thead><tr><th>Price</th><th>Shares</th></tr></thead>
                                            <tbody>
                                                @foreach (var o in _bookBids.OrderByDescending(o => o.Price))
                                                {
                                                    var bid = o;
                                                    <tr role="button" @onclick="() => FillAskFromBid(bid)" title="Sell at this price">
                                                        <td class="mono">@o.Price.ToString("N0")</td><td class="mono">@o.NumberOfShares.ToString("N0")</td>
                                                    </tr>
                                                }
                                            </tbody>
                                        </table>
                                    }
                                    else { <span class="text-muted small">No bids.</span> }
                                </div>
                            </div>
                        }
                    }
                    else
                    {
                        <div class="mb-2"><label class="form-label-sm">Asset: <strong class="mono">@_actionAssetName</strong></label></div>
                        <div class="mb-2"><label class="form-label-sm">Issuer</label>
                            <input class="form-control form-control-sm mono" readonly value="@_actionIssuer" /></div>

                        @if (_actionMode == ActionMode.Transfer)
                        {
                            <div class="mb-2"><label class="form-label-sm">Destination Identity</label>
                                <AddressInput @bind-Value="_actionDest" /></div>
                            <div class="mb-2"><label class="form-label-sm">Number of Shares (max: @_actionMaxShares.ToString("N0"))</label>
                                <input type="number" class="form-control form-control-sm" min="1" max="@_actionMaxShares" @bind="_actionShares" /></div>
                        }
                        else if (_actionMode == ActionMode.Rights)
                        {
                            <div class="mb-2"><label class="form-label-sm">New Managing Contract</label>
                                <select class="form-select form-select-sm" @bind="_actionContractIdx">
                                    @foreach (var c in Qubic.Core.QubicContracts.GetManagementRightsTargets())
                                    {
                                        <option value="@c.Index">@c.Name (@c.Index)</option>
                                    }
                                </select></div>
                            <div class="mb-2"><label class="form-label-sm">Number of Shares (max: @_actionMaxShares.ToString("N0"))</label>
                                <input type="number" class="form-control form-control-sm" min="1" max="@_actionMaxShares" @bind="_actionShares" /></div>
                            <div class="small text-muted">
                                Currently managed by: <strong>@Qubic.Core.QubicContracts.FormatContract(_actionCurrentManagingContract)</strong>
                            </div>
                        }
                        else @* Ask / Bid *@
                        {
                            <div class="mb-2"><label class="form-label-sm">Price per Share (QU)</label>
                                <input type="number" class="form-control form-control-sm" min="1" @bind="_actionPrice" /></div>
                            <div class="mb-2"><label class="form-label-sm">Number of Shares@(_actionMode == ActionMode.Ask ? $" (max: {_actionMaxShares:N0})" : "")</label>
                                <input type="number" class="form-control form-control-sm" min="1"
                                       max="@(_actionMode == ActionMode.Ask ? _actionMaxShares : long.MaxValue)" @bind="_actionShares" /></div>
                            @if (_actionMode == ActionMode.Bid && _actionPrice > 0 && _actionShares > 0)
                            {
                                <div class="small text-muted">Total cost: <strong>@((_actionPrice * _actionShares).ToString("N0")) QU</strong> (escrowed until matched)</div>
                            }
                        }

                        @if (_actionResult != null)
                        {
                            <div class="alert alert-success mt-2 mb-0">
                                Tx ID: <span class="mono">@_actionResult</span>
                                <div class="mt-1">
                                    <a href="https://explorer.qubic.org/network/tx/@_actionResult" target="_blank" rel="noopener" class="me-3">View on Explorer</a>
                                    <a href="/history">Transaction History</a>
                                </div>
                            </div>
                            @if (_actionMode == ActionMode.Transfer && Vault.IsUnlocked && !_dismissSaveContact && !string.IsNullOrEmpty(_actionDest) && !Vault.IsKnownAddress(_actionDest))
                            {
                                <div class="alert alert-info mt-2 py-2 mb-0 d-flex align-items-center gap-2 flex-wrap">
                                    <i class="bi bi-person-plus"></i>
                                    <span class="small">Save <span class="mono">@_actionDest[..12]...</span> to address book?</span>
                                    <input type="text" class="form-control form-control-sm" style="width:150px"
                                           @bind="_saveContactLabel" placeholder="Label" />
                                    <button class="btn btn-sm btn-outline-primary" @onclick="SaveNewContact">Save</button>
                                    <button class="btn btn-sm btn-outline-secondary" @onclick="() => _dismissSaveContact = true">
                                        <i class="bi bi-x"></i>
                                    </button>
                                </div>
                            }
                        }
                        @if (_actionError != null) { <div class="alert alert-danger mt-2 mb-0">@_actionError</div> }
                    }
                </div>
                @if (_actionMode != ActionMode.OrderBook)
                {
                    <div class="modal-footer d-flex justify-content-between align-items-center">
                        <span class="small text-muted">@GetFooterSummary()</span>
                        @switch (_actionMode)
                        {
                            case ActionMode.Transfer:
                                <button class="btn btn-primary" @onclick="ExecuteTransfer" disabled="@_actionSending">
                                    @(_actionSending ? "Transferring..." : "Transfer via QX")
                                </button>
                                break;
                            case ActionMode.Rights:
                                <button class="btn btn-primary" @onclick="ExecuteRights" disabled="@_actionSending">
                                    @(_actionSending ? "Sending..." : $"Change Rights via {Qubic.Core.QubicContracts.GetContractName(_actionCurrentManagingContract) ?? "Contract"}")
                                </button>
                                break;
                            case ActionMode.Ask:
                                <button class="btn btn-success" @onclick="ExecuteAsk" disabled="@_actionSending">
                                    @(_actionSending ? "Placing..." : "Place Sell Order")
                                </button>
                                break;
                            case ActionMode.Bid:
                                <button class="btn btn-warning" @onclick="ExecuteBid" disabled="@_actionSending">
                                    @(_actionSending ? "Placing..." : "Place Buy Order")
                                </button>
                                break;
                        }
                    </div>
                }
            </div>
        </div>
    </div>
}

@code {
    private string? _identity;
    private IReadOnlyList<Qubic.Rpc.Models.OwnedAssetInfo>? _owned;
    private IReadOnlyList<Qubic.Rpc.Models.PossessedAssetInfo>? _possessed;
    private IReadOnlyList<Qubic.Rpc.Models.IssuedAssetInfo>? _issued;
    private bool _loading;
    private string? _error;
    private const int QxContractIndex = 1;
    private const int QswapContractIndex = 13;

    // QX fees
    private (uint issuance, uint transfer, uint trade)? _qxFees;

    // Open orders
    private List<Qubic.Core.Contracts.Qx.EntityAskOrdersOrder>? _myAskOrders;
    private List<Qubic.Core.Contracts.Qx.EntityBidOrdersOrder>? _myBidOrders;
    private bool _ordersLoading;
    private readonly Dictionary<string, string> _pendingCancels = new(); // orderKey → txHash

    // Order book
    private List<Qubic.Core.Contracts.Qx.AssetAskOrdersOrder>? _bookAsks;
    private List<Qubic.Core.Contracts.Qx.AssetBidOrdersOrder>? _bookBids;
    private bool _bookLoading;

    // QSwap pools
    private Dictionary<string, (long quReserve, long assetReserve)>? _qswapPools;

    // Action panel
    private enum ActionMode { None, Transfer, Rights, Ask, Bid, OrderBook }
    private ActionMode _actionMode;
    private string _actionAssetName = "";
    private string _actionIssuer = "";
    private long _actionMaxShares;
    private long _actionShares;
    private string? _actionDest;
    private int _actionContractIdx;
    private int _actionCurrentManagingContract;
    private ulong? _actionRightsFee;
    private long _actionPrice;
    private bool _actionSending;
    private string? _actionResult;

    // Save to address book
    private string? _saveContactLabel;
    private bool _dismissSaveContact;
    private void SaveNewContact()
    {
        if (string.IsNullOrWhiteSpace(_saveContactLabel) || string.IsNullOrEmpty(_actionDest)) return;
        try { Vault.AddContact(_saveContactLabel, _actionDest.Trim()); } catch { }
        _saveContactLabel = null;
        _dismissSaveContact = true;
    }
    private string? _actionError;

    protected override async Task OnInitializedAsync()
    {
        TxTracker.OnChanged += OnTrackerChanged;
        _ = LoadQxFees();
        if (Seed.HasSeed)
        {
            _identity = Seed.Identity!.ToString();
            var lookupTask = Lookup();
            var ordersTask = LoadOpenOrders();
            await Task.WhenAll(lookupTask, ordersTask);
        }
    }

    private async Task LoadQxFees()
    {
        try
        {
            var result = await Backend.QuerySmartContractAsync(QxContractIndex, 1, []);
            if (result.Length >= 12)
                _qxFees = (BitConverter.ToUInt32(result, 0), BitConverter.ToUInt32(result, 4), BitConverter.ToUInt32(result, 8));
        }
        catch { }
    }

    private async Task LoadOpenOrders()
    {
        if (!Seed.HasSeed || Seed.Identity == null) return;
        _ordersLoading = true;
        try
        {
            var pk = Seed.Identity.Value.PublicKey;
            var askInput = new Qubic.Core.Contracts.Qx.EntityAskOrdersInput { Entity = pk, Offset = 0 }.ToBytes();
            var bidInput = new Qubic.Core.Contracts.Qx.EntityBidOrdersInput { Entity = pk, Offset = 0 }.ToBytes();
            var askTask = Backend.QuerySmartContractAsync(QxContractIndex, 4, askInput);
            var bidTask = Backend.QuerySmartContractAsync(QxContractIndex, 5, bidInput);
            await Task.WhenAll(askTask, bidTask);

            if (askTask.Result.Length >= Qubic.Core.Contracts.Qx.EntityAskOrdersOrder.Size)
                _myAskOrders = Qubic.Core.Contracts.Qx.EntityAskOrdersOutput.FromBytes(askTask.Result)
                    .Orders.Where(o => o.NumberOfShares > 0).ToList();
            if (bidTask.Result.Length >= Qubic.Core.Contracts.Qx.EntityBidOrdersOrder.Size)
                _myBidOrders = Qubic.Core.Contracts.Qx.EntityBidOrdersOutput.FromBytes(bidTask.Result)
                    .Orders.Where(o => o.NumberOfShares > 0).ToList();
        }
        catch { }
        finally { _ordersLoading = false; }
    }

    private async Task LoadQswapPools()
    {
        if (_owned == null || _owned.Count == 0) return;
        var pools = new Dictionary<string, (long, long)>();
        var tasks = new List<(string key, Task<byte[]> task)>();

        foreach (var a in _owned)
        {
            var issuer = a.Data.IssuedAsset?.IssuerIdentity ?? "";
            var name = a.Data.IssuedAsset?.Name ?? "";
            if (string.IsNullOrEmpty(issuer) || string.IsNullOrEmpty(name)) continue;
            var key = $"{issuer}:{name}";
            if (tasks.Any(t => t.key == key)) continue;

            try
            {
                var pk = Qubic.Core.Entities.QubicIdentity.FromIdentity(issuer.Trim()).PublicKey;
                var input = new Qubic.Core.Contracts.Qswap.GetPoolBasicStateInput
                {
                    AssetIssuer = pk,
                    AssetName = AssetNameHelper.ToUlong(name)
                }.ToBytes();
                tasks.Add((key, Backend.QuerySmartContractAsync(QswapContractIndex, 2, input)));
            }
            catch { }
        }

        if (tasks.Count > 0)
        {
            await Task.WhenAll(tasks.Select(t => t.task));
            foreach (var (key, task) in tasks)
            {
                try
                {
                    var data = task.Result;
                    if (data.Length >= 32)
                    {
                        var state = Qubic.Core.Contracts.Qswap.GetPoolBasicStateOutput.FromBytes(data);
                        if (state.PoolExists != 0)
                            pools[key] = (state.ReservedQuAmount, state.ReservedAssetAmount);
                    }
                }
                catch { }
            }
        }

        _qswapPools = pools;
    }

    private string GetModalTitle() => _actionMode switch
    {
        ActionMode.Transfer => "Transfer Asset",
        ActionMode.Rights => "Change Management Rights",
        ActionMode.Ask => "Sell on QX",
        ActionMode.Bid => "Buy on QX",
        ActionMode.OrderBook => "Order Book",
        _ => ""
    };

    private string GetFooterSummary() => _actionMode switch
    {
        ActionMode.Transfer => $"Fee: {(_qxFees?.transfer ?? 0):N0} QU | Shares: {_actionShares:N0}",
        ActionMode.Rights => $"Fee: {(_actionRightsFee ?? 0):N0} QU | Shares: {_actionShares:N0}",
        ActionMode.Ask => $"Shares: {_actionShares:N0} | Price: {_actionPrice:N0} QU each | Trade fee: {FormatTradeFee()} on match",
        ActionMode.Bid => $"Total: {_actionPrice * _actionShares:N0} QU | Trade fee: {FormatTradeFee()} on match",
        _ => ""
    };

    private string FormatTradeFee()
    {
        if (_qxFees == null) return "?";
        var pct = _qxFees.Value.trade / 10_000_000.0;
        return pct % 1 == 0 ? $"{pct:F0}%" : $"{pct:G}%";
    }

    private void OpenAction(ActionMode mode, string assetName, string issuer, long units)
    {
        _actionMode = mode;
        _actionAssetName = assetName;
        _actionIssuer = issuer;
        _actionMaxShares = units;
        _actionShares = units;
        _actionDest = null;
        _actionPrice = 0;
        _actionResult = null;
        _actionError = null;
    }

    private void OpenTransfer(string assetName, string issuer, long units)
        => OpenAction(ActionMode.Transfer, assetName, issuer, units);

    private void OpenAsk(string assetName, string issuer, long units)
        => OpenAction(ActionMode.Ask, assetName, issuer, units);

    private void OpenBid(string assetName, string issuer, long units)
    {
        OpenAction(ActionMode.Bid, assetName, issuer, units);
        _actionShares = 1;
    }

    private void OpenRights(string assetName, string issuer, long units, int currentManagingContract)
    {
        OpenAction(ActionMode.Rights, assetName, issuer, units);
        _actionContractIdx = 0;
        _actionCurrentManagingContract = currentManagingContract;
        _actionRightsFee = StaticData.GetContractFee(currentManagingContract, "Transfer Share Management Rights");
    }

    private void OpenVaultDeposit(string assetName, string issuer)
        => Nav.NavigateTo($"/msvault?tab=Assets&op=deposit&issuer={Uri.EscapeDataString(issuer)}&asset={Uri.EscapeDataString(assetName)}");

    private async Task OpenOrderBook(string assetName, string issuer)
    {
        _actionMode = ActionMode.OrderBook;
        _actionAssetName = assetName;
        _actionIssuer = issuer;
        _bookLoading = true;
        _bookAsks = null;
        _bookBids = null;
        StateHasChanged();

        try
        {
            var issuerPk = Qubic.Core.Entities.QubicIdentity.FromIdentity(issuer.Trim()).PublicKey;
            var assetNameUlong = AssetNameHelper.ToUlong(assetName);
            var askInput = new Qubic.Core.Contracts.Qx.AssetAskOrdersInput { Issuer = issuerPk, AssetName = assetNameUlong, Offset = 0 }.ToBytes();
            var bidInput = new Qubic.Core.Contracts.Qx.AssetBidOrdersInput { Issuer = issuerPk, AssetName = assetNameUlong, Offset = 0 }.ToBytes();
            var askTask = Backend.QuerySmartContractAsync(QxContractIndex, 2, askInput);
            var bidTask = Backend.QuerySmartContractAsync(QxContractIndex, 3, bidInput);
            await Task.WhenAll(askTask, bidTask);

            if (askTask.Result.Length >= Qubic.Core.Contracts.Qx.AssetAskOrdersOrder.Size)
                _bookAsks = Qubic.Core.Contracts.Qx.AssetAskOrdersOutput.FromBytes(askTask.Result)
                    .Orders.Where(o => o.NumberOfShares > 0).ToList();
            if (bidTask.Result.Length >= Qubic.Core.Contracts.Qx.AssetBidOrdersOrder.Size)
                _bookBids = Qubic.Core.Contracts.Qx.AssetBidOrdersOutput.FromBytes(bidTask.Result)
                    .Orders.Where(o => o.NumberOfShares > 0).ToList();
        }
        catch { }
        finally { _bookLoading = false; }
    }

    private void FillBidFromAsk(Qubic.Core.Contracts.Qx.AssetAskOrdersOrder ask)
    {
        _actionMode = ActionMode.Bid;
        _actionPrice = ask.Price;
        _actionShares = ask.NumberOfShares;
        _actionResult = null;
        _actionError = null;
    }

    private void FillAskFromBid(Qubic.Core.Contracts.Qx.AssetBidOrdersOrder bid)
    {
        _actionMode = ActionMode.Ask;
        _actionPrice = bid.Price;
        _actionShares = bid.NumberOfShares;
        _actionResult = null;
        _actionError = null;
    }

    private void CloseAction() => _actionMode = ActionMode.None;

    private async Task CancelAskOrder(Qubic.Core.Contracts.Qx.EntityAskOrdersOrder order, string key)
    {
        try
        {
            var tick = await GetTick();
            var payload = new Qubic.Core.Contracts.Qx.RemoveFromAskOrderPayload
            {
                Issuer = order.Issuer,
                AssetName = order.AssetName,
                Price = order.Price,
                NumberOfShares = order.NumberOfShares
            };
            var dest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(Qubic.Core.QubicContracts.GetContractPublicKey(QxContractIndex));
            var tx = Seed.CreateAndSignTransaction(dest, 0, tick, payload);
            var result = await Backend.BroadcastTransactionAsync(tx);
            var name = Qubic.Core.AssetNameHelper.FromUlong(order.AssetName) ?? "?";
            TxTracker.Track(new TrackedTransaction { Hash = result.TransactionId, Source = Seed.Identity?.ToString() ?? "",
                Destination = dest.ToString(), Amount = 0, TargetTick = tick,
                InputType = payload.InputType, PayloadHex = Convert.ToHexString(payload.GetPayloadBytes()),
                Description = $"Cancel Ask {name}: {order.NumberOfShares:N0} @ {order.Price:N0} QU",
                RawData = Convert.ToHexString(tx.GetRawBytes()) });
            _pendingCancels[key] = result.TransactionId;
        }
        catch { }
    }

    private async Task CancelBidOrder(Qubic.Core.Contracts.Qx.EntityBidOrdersOrder order, string key)
    {
        try
        {
            var tick = await GetTick();
            var payload = new Qubic.Core.Contracts.Qx.RemoveFromBidOrderPayload
            {
                Issuer = order.Issuer,
                AssetName = order.AssetName,
                Price = order.Price,
                NumberOfShares = order.NumberOfShares
            };
            var dest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(Qubic.Core.QubicContracts.GetContractPublicKey(QxContractIndex));
            var tx = Seed.CreateAndSignTransaction(dest, 0, tick, payload);
            var result = await Backend.BroadcastTransactionAsync(tx);
            var name = Qubic.Core.AssetNameHelper.FromUlong(order.AssetName) ?? "?";
            TxTracker.Track(new TrackedTransaction { Hash = result.TransactionId, Source = Seed.Identity?.ToString() ?? "",
                Destination = dest.ToString(), Amount = 0, TargetTick = tick,
                InputType = payload.InputType, PayloadHex = Convert.ToHexString(payload.GetPayloadBytes()),
                Description = $"Cancel Bid {name}: {order.NumberOfShares:N0} @ {order.Price:N0} QU",
                RawData = Convert.ToHexString(tx.GetRawBytes()) });
            _pendingCancels[key] = result.TransactionId;
        }
        catch { }
    }

    private bool IsCancelPending(string orderKey)
    {
        if (!_pendingCancels.TryGetValue(orderKey, out var txHash)) return false;
        var tx = TxTracker.Transactions.FirstOrDefault(t => t.Hash == txHash);
        if (tx == null || tx.Status != TrackedTxStatus.Pending)
        {
            _pendingCancels.Remove(orderKey);
            return false;
        }
        return true;
    }

    private void OnTrackerChanged()
    {
        // Check if any pending cancel resolved — reload orders when it does
        var anyResolved = false;
        foreach (var (key, txHash) in _pendingCancels.ToList())
        {
            var tx = TxTracker.Transactions.FirstOrDefault(t => t.Hash == txHash);
            if (tx == null || tx.Status != TrackedTxStatus.Pending)
            {
                _pendingCancels.Remove(key);
                anyResolved = true;
            }
        }
        if (anyResolved)
            _ = InvokeAsync(async () => { await LoadOpenOrders(); StateHasChanged(); });
        else
            InvokeAsync(StateHasChanged);
    }

    private async Task<uint> GetTick() => TickMonitor.IsConnected
        ? TickMonitor.Tick + (uint)Settings.TickOffset
        : (await Backend.GetTickInfoAsync()).Tick + (uint)Settings.TickOffset;

    private async Task ExecuteTransfer()
    {
        _actionSending = true; _actionError = null; _actionResult = null;
        try
        {
            var destErr = IdentityValidation.Validate(_actionDest);
            if (destErr != null) { _actionError = $"Destination: {destErr}"; return; }
            if (_actionShares <= 0 || _actionShares > _actionMaxShares) { _actionError = "Invalid share count."; return; }

            var tick = await GetTick();
            var issuerPk = Qubic.Core.Entities.QubicIdentity.FromIdentity(_actionIssuer.Trim()).PublicKey;
            var destPk = Qubic.Core.Entities.QubicIdentity.FromIdentity(_actionDest!.Trim()).PublicKey;

            var payload = new Qubic.Core.Contracts.Qx.TransferShareOwnershipAndPossessionPayload
            {
                Issuer = issuerPk,
                AssetName = AssetNameHelper.ToUlong(_actionAssetName),
                NewOwnerAndPossessor = destPk,
                NumberOfShares = _actionShares
            };

            var dest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(Qubic.Core.QubicContracts.GetContractPublicKey(QxContractIndex));
            long txFee = _qxFees?.transfer ?? 0;
            var tx = Seed.CreateAndSignTransaction(dest, txFee, tick, payload);
            var result = await Backend.BroadcastTransactionAsync(tx);
            _actionResult = result.TransactionId;
            TxTracker.Track(new TrackedTransaction { Hash = result.TransactionId, Source = Seed.Identity?.ToString() ?? "",
                Destination = dest.ToString(), Amount = txFee, TargetTick = tick,
                InputType = payload.InputType, PayloadHex = Convert.ToHexString(payload.GetPayloadBytes()),
                Description = $"Transfer {_actionAssetName}: {_actionShares:N0} shares",
                RawData = Convert.ToHexString(tx.GetRawBytes()) });
        }
        catch (Exception ex) { _actionError = ex.Message; }
        finally { _actionSending = false; }
    }

    private async Task ExecuteRights()
    {
        _actionSending = true; _actionError = null; _actionResult = null;
        try
        {
            if (_actionShares <= 0 || _actionShares > _actionMaxShares) { _actionError = "Invalid share count."; return; }

            var tick = await GetTick();
            var issuerPk = Qubic.Core.Entities.QubicIdentity.FromIdentity(_actionIssuer.Trim()).PublicKey;
            var asset = new Qubic.Core.Contracts.QubicAsset { Issuer = issuerPk, AssetName = AssetNameHelper.ToUlong(_actionAssetName) };

            var payload = Qubic.Core.QubicContracts.CreateManagementRightsPayload(
                _actionCurrentManagingContract, asset, _actionShares, (uint)_actionContractIdx);

            var dest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(
                Qubic.Core.QubicContracts.GetContractPublicKey(_actionCurrentManagingContract));
            var txFee = _actionRightsFee ?? 0;
            var tx = Seed.CreateAndSignTransaction(dest, (long)txFee, tick, payload);
            var result = await Backend.BroadcastTransactionAsync(tx);
            _actionResult = result.TransactionId;
            var contractName = Qubic.Core.QubicContracts.GetContractName(_actionCurrentManagingContract) ?? _actionCurrentManagingContract.ToString();
            TxTracker.Track(new TrackedTransaction { Hash = result.TransactionId, Source = Seed.Identity?.ToString() ?? "",
                Destination = dest.ToString(), Amount = 0, TargetTick = tick,
                InputType = payload.InputType, PayloadHex = Convert.ToHexString(payload.GetPayloadBytes()),
                Description = $"Change Rights {_actionAssetName}: {_actionShares:N0} shares → contract {_actionContractIdx} (via {contractName})",
                RawData = Convert.ToHexString(tx.GetRawBytes()) });
        }
        catch (Exception ex) { _actionError = ex.Message; }
        finally { _actionSending = false; }
    }

    private async Task ExecuteAsk()
    {
        _actionSending = true; _actionError = null; _actionResult = null;
        try
        {
            if (_actionPrice <= 0) { _actionError = "Price must be positive."; return; }
            if (_actionShares <= 0 || _actionShares > _actionMaxShares) { _actionError = $"Shares must be between 1 and {_actionMaxShares:N0}."; return; }

            var tick = await GetTick();
            var issuerPk = Qubic.Core.Entities.QubicIdentity.FromIdentity(_actionIssuer.Trim()).PublicKey;

            var payload = new Qubic.Core.Contracts.Qx.AddToAskOrderPayload
            {
                Issuer = issuerPk,
                AssetName = AssetNameHelper.ToUlong(_actionAssetName),
                Price = _actionPrice,
                NumberOfShares = _actionShares
            };

            var dest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(Qubic.Core.QubicContracts.GetContractPublicKey(QxContractIndex));
            var tx = Seed.CreateAndSignTransaction(dest, 0, tick, payload);
            var result = await Backend.BroadcastTransactionAsync(tx);
            _actionResult = result.TransactionId;
            TxTracker.Track(new TrackedTransaction { Hash = result.TransactionId, Source = Seed.Identity?.ToString() ?? "",
                Destination = dest.ToString(), Amount = 0, TargetTick = tick,
                InputType = payload.InputType, PayloadHex = Convert.ToHexString(payload.GetPayloadBytes()),
                Description = $"QX Ask {_actionAssetName}: {_actionShares:N0} @ {_actionPrice:N0} QU",
                RawData = Convert.ToHexString(tx.GetRawBytes()) });
        }
        catch (Exception ex) { _actionError = ex.Message; }
        finally { _actionSending = false; }
    }

    private async Task ExecuteBid()
    {
        _actionSending = true; _actionError = null; _actionResult = null;
        try
        {
            if (_actionPrice <= 0) { _actionError = "Price must be positive."; return; }
            if (_actionShares <= 0) { _actionError = "Share count must be positive."; return; }

            var tick = await GetTick();
            var issuerPk = Qubic.Core.Entities.QubicIdentity.FromIdentity(_actionIssuer.Trim()).PublicKey;

            var payload = new Qubic.Core.Contracts.Qx.AddToBidOrderPayload
            {
                Issuer = issuerPk,
                AssetName = AssetNameHelper.ToUlong(_actionAssetName),
                Price = _actionPrice,
                NumberOfShares = _actionShares
            };

            long amount = _actionPrice * _actionShares;
            var dest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(Qubic.Core.QubicContracts.GetContractPublicKey(QxContractIndex));
            var tx = Seed.CreateAndSignTransaction(dest, amount, tick, payload);
            var result = await Backend.BroadcastTransactionAsync(tx);
            _actionResult = result.TransactionId;
            TxTracker.Track(new TrackedTransaction { Hash = result.TransactionId, Source = Seed.Identity?.ToString() ?? "",
                Destination = dest.ToString(), Amount = amount, TargetTick = tick,
                InputType = payload.InputType, PayloadHex = Convert.ToHexString(payload.GetPayloadBytes()),
                Description = $"QX Bid {_actionAssetName}: {_actionShares:N0} @ {_actionPrice:N0} QU",
                RawData = Convert.ToHexString(tx.GetRawBytes()) });
        }
        catch (Exception ex) { _actionError = ex.Message; }
        finally { _actionSending = false; }
    }

    private async Task Lookup()
    {
        if (IdentityValidation.Validate(_identity) != null) return;

        _loading = true;
        _error = null;
        _owned = null;
        _possessed = null;
        _issued = null;
        _qswapPools = null;

        try
        {
            var id = Qubic.Core.Entities.QubicIdentity.FromIdentity(_identity!.Trim());
            var ownedTask = Backend.GetOwnedAssetsAsync(id);
            var possessedTask = Backend.GetPossessedAssetsAsync(id);
            var issuedTask = Backend.GetIssuedAssetsAsync(id);

            await Task.WhenAll(ownedTask, possessedTask, issuedTask);

            _owned = ownedTask.Result;
            _possessed = possessedTask.Result;
            _issued = issuedTask.Result;

            _ = LoadQswapPools();
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
        finally
        {
            _loading = false;
        }
    }

    public void Dispose()
    {
        TxTracker.OnChanged -= OnTrackerChanged;
    }
}
