@page "/qearn"
@inject QubicBackendService Backend
@inject SeedSessionService Seed
@inject TickMonitorService TickMonitor
@inject TransactionTrackerService TxTracker
@inject QubicSettingsService Settings
@inject IJSRuntime JS
@inject VaultService Vault

<h4>QEarn Staking</h4>
<p class="text-muted">Lock QU to earn rewards, unlock, and query staking information.</p>

@if (_autoLoading)
{
    <div class="text-muted mb-3"><span class="spinner-border spinner-border-sm me-1"></span> Loading your staking info...</div>
}
else if (_activeLocks.Count > 0 || _autoEndedStatus != null)
{
    <div class="card mb-3 border-primary">
        <div class="card-header card-header-accent">Your Staking Summary</div>
        <div class="card-body">
            <div class="table-responsive">
                <table class="table table-sm table-hover mb-2">
                    <thead>
                        <tr>
                            <th>Lock Epoch</th>
                            <th>Locked Amount</th>
                            <th>Week</th>
                            <th>Remaining</th>
                            <th>Yield</th>
                            <th>Est. Full Reward</th>
                            <th title="Reward if unlocked now based on early unlock schedule">Early Unlock</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var l in _activeLocks)
                        {
                            var yieldPct = l.Yield > 0 ? (double)l.Yield / 100_000 : 0;
                            var earlyPct = GetEarlyUnlockRewardPercent(l.Week);
                            var earlyReward = l.EstReward * (ulong)earlyPct / 100;
                            var lk = l;
                            <tr>
                                <td class="mono">@l.Epoch</td>
                                <td class="mono">@l.Amount.ToString("N0") QU</td>
                                <td>@l.Week / 52</td>
                                <td>@l.Remaining week@(l.Remaining != 1 ? "s" : "")</td>
                                <td class="mono">@(l.Yield > 0 ? $"{yieldPct:F2}%" : "—")</td>
                                <td class="mono text-success">@(l.EstReward > 0 ? $"+{l.EstReward:N0} QU" : "—")</td>
                                <td class="mono @(earlyPct < 100 ? "text-warning" : "text-success")" title="@earlyPct% of full reward">
                                    @if (l.EstReward > 0)
                                    {
                                        @($"+{earlyReward:N0} QU ({earlyPct}%)")
                                    }
                                    else
                                    {
                                        @("—")
                                    }
                                </td>
                                <td>
                                    @if (Seed.HasSeed)
                                    {
                                        <button class="btn btn-sm btn-outline-warning" @onclick="() => UnlockFromSummary(lk)"
                                                disabled="@(_sending)">
                                            @(_unlockingEpoch == l.Epoch ? "Unlocking..." : "Unlock")
                                        </button>
                                    }
                                </td>
                            </tr>
                        }
                        @if (_autoEndedStatus != null)
                        {
                            var es = _autoEndedStatus.Value;
                            @if (es.fullyUnlocked > 0)
                            {
                                <tr class="table-success">
                                    <td colspan="4" class="mono">Fully Unlocked: @es.fullyUnlocked.ToString("N0") QU</td>
                                    <td colspan="4" class="mono">Rewarded: @es.fullyRewarded.ToString("N0") QU</td>
                                </tr>
                            }
                            @if (es.earlyUnlocked > 0)
                            {
                                <tr class="table-warning">
                                    <td colspan="4" class="mono">Early Unlocked: @es.earlyUnlocked.ToString("N0") QU</td>
                                    <td colspan="4" class="mono">Rewarded: @es.earlyRewarded.ToString("N0") QU</td>
                                </tr>
                            }
                        }
                    </tbody>
                </table>
            </div>
            @if (_activeLocks.Count > 0)
            {
                <div class="small text-muted">
                    Total locked: <strong>@_activeLocks.Sum(l => (long)l.Amount).ToString("N0") QU</strong> across <strong>@_activeLocks.Count</strong> epoch@(_activeLocks.Count != 1 ? "s" : "")
                    @if (_activeLocks.Sum(l => (long)l.EstReward) > 0)
                    {
                        <span class="ms-2">| Est. total reward at full unlock: <strong class="text-success">+@_activeLocks.Sum(l => (long)l.EstReward).ToString("N0") QU</strong></span>
                    }
                </div>
            }
        </div>
    </div>
}

<ul class="nav nav-tabs mb-3">
    @foreach (var tab in _tabs)
    {
        <li class="nav-item">
            <a class="nav-link @(tab == _activeTab ? "active" : "")" href="" @onclick="() => _activeTab = tab" @onclick:preventDefault>@tab</a>
        </li>
    }
</ul>

<div class="row"><div class="col-md-8">
    @switch (_activeTab)
    {
        case "Lock":
            <div class="card"><div class="card-header">Lock QU</div><div class="card-body">
                <p class="small text-muted">Lock QU into QEarn smart contract to earn staking rewards.</p>
                <div class="mb-2">
                    <label class="form-label-sm">Amount to lock (QU)</label>
                    <input type="number" class="form-control form-control-sm" min="1" @bind="_lockAmount" />
                    <div class="form-text">The full amount will be locked. No additional fee.</div>
                </div>
                <button class="btn btn-primary" @onclick="Lock" disabled="@(_sending || _lockAmount <= 0)">
                    @(_sending ? "Locking..." : "Lock")
                </button>
            </div></div>
            break;

        case "Query":
            <div class="card"><div class="card-header">Query QEarn</div><div class="card-body">
                <div class="mb-3">
                    <label class="form-label-sm">Query Function</label>
                    <select class="form-select form-select-sm" @bind="_queryFunc">
                        <option value="1">Lock Info Per Epoch</option>
                        <option value="2">User Locked Info</option>
                        <option value="3">State of Round</option>
                        <option value="4">User Lock Status (52-week bitmask)</option>
                        <option value="5">Ended Status</option>
                        <option value="6">Stats Per Epoch</option>
                        <option value="7">Burned &amp; Boosted Stats (global)</option>
                        <option value="8">Burned &amp; Boosted Stats Per Epoch</option>
                    </select>
                </div>

                @if (_queryFunc is 1 or 3 or 6 or 8)
                {
                    <div class="mb-2">
                        <label class="form-label-sm">Epoch</label>
                        <input type="number" class="form-control form-control-sm" min="0" @bind="_qEpoch" />
                    </div>
                }
                @if (_queryFunc is 2 or 4 or 5)
                {
                    <div class="mb-2">
                        <label class="form-label-sm">User Identity</label>
                        <AddressInput @bind-Value="_qIdentity" />
                    </div>
                }
                @if (_queryFunc == 2)
                {
                    <div class="mb-2">
                        <label class="form-label-sm">Epoch</label>
                        <input type="number" class="form-control form-control-sm" min="0" @bind="_qEpoch" />
                    </div>
                }

                <button class="btn btn-primary" @onclick="RunQuery" disabled="@_querying">
                    @(_querying ? "Querying..." : "Query")
                </button>

                @if (_queryResult != null)
                {
                    <div class="mt-3">
                        <table class="table table-sm table-bordered">
                            <tbody>
                                @foreach (var kv in _queryResult)
                                {
                                    <tr><th class="text-muted" style="width:40%">@kv.Key</th><td class="mono">@kv.Value</td></tr>
                                }
                            </tbody>
                        </table>
                    </div>
                }

                @if (_lockStatusBits != null)
                {
                    <div class="mt-3">
                        <label class="form-label-sm">Lock Status (52 weeks, bit 0 = earliest)</label>
                        <div class="d-flex flex-wrap gap-1 mt-1">
                            @for (int i = 0; i < 52; i++)
                            {
                                var bit = i;
                                var locked = (_lockStatusBits.Value >> bit & 1) == 1;
                                <span class="badge @(locked ? "bg-success" : "bg-secondary")" title="Week @(bit + 1)"
                                      style="width:24px; font-size:0.65rem">@(bit + 1)</span>
                            }
                        </div>
                        <div class="small text-muted mt-1">
                            <span class="badge bg-success">N</span> = locked &nbsp;
                            <span class="badge bg-secondary">N</span> = not locked
                        </div>
                    </div>
                }
            </div></div>
            break;
    }

    @if (_result != null)
    {
        <div class="alert alert-success mt-3">
            Transaction broadcast! Tx ID: <TxHashDisplay Hash="@_result" ShowFull="true" />
            <div class="mt-1">
                <a href="/history">Transaction History</a>
            </div>
        </div>
    }
    @if (_error != null) { <div class="alert alert-danger mt-2">@_error</div> }
</div></div>

@code {
    private static readonly string[] _tabs = ["Lock", "Query"];
    private string _activeTab = "Lock";
    private bool _sending;
    private string? _result;
    private string? _error;
    private const int ContractIndex = 9;

    // Auto-query
    private bool _autoLoading;
    private List<ActiveLock> _activeLocks = [];
    private (ulong fullyUnlocked, ulong fullyRewarded, ulong earlyUnlocked, ulong earlyRewarded)? _autoEndedStatus;

    private record ActiveLock(uint Epoch, ulong Amount, int Week, int Remaining, ulong Yield, ulong EstReward);

    // Lock
    private long _lockAmount;
    // Unlock (from summary)
    private uint? _unlockingEpoch;

    // Query
    private int _queryFunc = 1;
    private uint _qEpoch;
    private string? _qIdentity;
    private bool _querying;
    private List<KeyValuePair<string, string>>? _queryResult;
    private ulong? _lockStatusBits;

    protected override async Task OnInitializedAsync()
    {
        // Default query epoch to current epoch
        if (TickMonitor.IsConnected && TickMonitor.Epoch > 0)
            _qEpoch = (uint)TickMonitor.Epoch;

        if (Seed.HasSeed)
        {
            _autoLoading = true;
            try
            {
                var pk = Seed.Identity!.Value.PublicKey;
                var currentEpoch = TickMonitor.IsConnected ? TickMonitor.Epoch : 0u;
                if (currentEpoch == 0)
                {
                    try { currentEpoch = (await Backend.GetTickInfoAsync()).Epoch; } catch { }
                }
                if (_qEpoch == 0 && currentEpoch > 0)
                    _qEpoch = currentEpoch;

                // Query lock status bitmask (function 4)
                var lockInput = new Qubic.Core.Contracts.Qearn.GetUserLockStatusInput { User = pk }.ToBytes();
                var lockResult = await Backend.QuerySmartContractAsync(ContractIndex, 4, lockInput);
                if (lockResult.Length >= 8 && currentEpoch > 0)
                {
                    var ls = Qubic.Core.Contracts.Qearn.GetUserLockStatusOutput.FromBytes(lockResult);

                    // Bit N in the status = locked for N weeks (lockEpoch = currentEpoch - N)
                    var tasks = new List<(int WeeksLocked, uint LockEpoch, Task<byte[]> QueryTask)>();
                    for (int i = 1; i < 52; i++) // bit 0 would mean locked this epoch (0 weeks)
                    {
                        if ((ls.Status >> i & 1) == 1)
                        {
                            var lockEpoch = currentEpoch - (uint)i;
                            var amountInput = new Qubic.Core.Contracts.Qearn.GetUserLockedInfoInput { User = pk, Epoch = lockEpoch }.ToBytes();
                            tasks.Add((i, lockEpoch, Backend.QuerySmartContractAsync(ContractIndex, 2, amountInput)));
                        }
                    }
                    // Also check bit 0 (locked this epoch)
                    if ((ls.Status & 1) == 1)
                    {
                        var amountInput = new Qubic.Core.Contracts.Qearn.GetUserLockedInfoInput { User = pk, Epoch = currentEpoch }.ToBytes();
                        tasks.Add((0, currentEpoch, Backend.QuerySmartContractAsync(ContractIndex, 2, amountInput)));
                    }

                    if (tasks.Count > 0)
                    {
                        // Also query lock info per epoch (function 1) for yield data
                        var yieldTasks = new Dictionary<uint, Task<byte[]>>();
                        foreach (var (_, lockEpoch, _) in tasks)
                        {
                            if (!yieldTasks.ContainsKey(lockEpoch))
                            {
                                var yieldInput = new Qubic.Core.Contracts.Qearn.GetLockInfoPerEpochInput { Epoch = lockEpoch }.ToBytes();
                                yieldTasks[lockEpoch] = Backend.QuerySmartContractAsync(ContractIndex, 1, yieldInput);
                            }
                        }

                        await Task.WhenAll(tasks.Select(t => t.QueryTask).Concat(yieldTasks.Values));

                        foreach (var (weeksLocked, lockEpoch, queryTask) in tasks)
                        {
                            ulong amount = 0;
                            try
                            {
                                var amountResult = queryTask.Result;
                                if (amountResult.Length >= 8)
                                    amount = Qubic.Core.Contracts.Qearn.GetUserLockedInfoOutput.FromBytes(amountResult).LockedAmount;
                            }
                            catch { }

                            ulong yield = 0;
                            try
                            {
                                if (yieldTasks.TryGetValue(lockEpoch, out var yt) && yt.Result.Length >= 40)
                                    yield = Qubic.Core.Contracts.Qearn.GetLockInfoPerEpochOutput.FromBytes(yt.Result).Yield;
                            }
                            catch { }

                            var estReward = yield > 0 ? amount * yield / 10_000_000 : 0;
                            var remaining = 52 - weeksLocked;
                            _activeLocks.Add(new ActiveLock(lockEpoch, amount, weeksLocked, remaining, yield, estReward));
                        }
                        _activeLocks = _activeLocks.OrderBy(l => l.Epoch).ToList();
                    }
                }

                // Query ended status (function 5)
                var endedInput = new Qubic.Core.Contracts.Qearn.GetEndedStatusInput { User = pk }.ToBytes();
                var endedResult = await Backend.QuerySmartContractAsync(ContractIndex, 5, endedInput);
                if (endedResult.Length >= 32)
                {
                    var es = Qubic.Core.Contracts.Qearn.GetEndedStatusOutput.FromBytes(endedResult);
                    _autoEndedStatus = (es.FullyUnlockedAmount, es.FullyRewardedAmount, es.EarlyUnlockedAmount, es.EarlyRewardedAmount);
                }
            }
            catch { }
            finally { _autoLoading = false; }
        }
    }

    private async Task<uint> GetTick() => TickMonitor.IsConnected
        ? TickMonitor.Tick + (uint)Settings.TickOffset
        : (await Backend.GetTickInfoAsync()).Tick + (uint)Settings.TickOffset;

    private async Task Broadcast(long amount, uint tick, Qubic.Core.Payloads.ITransactionPayload payload, string desc)
    {
        var dest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(Qubic.Core.QubicContracts.GetContractPublicKey(ContractIndex));
        var tx = Seed.CreateAndSignTransaction(dest, amount, tick, payload);
        var result = await Backend.BroadcastTransactionAsync(tx);
        _result = result.TransactionId;
        TxTracker.Track(new TrackedTransaction { Hash = result.TransactionId, Source = Seed.Identity?.ToString() ?? "",
            Destination = dest.ToString(), Amount = amount, TargetTick = tick,
            InputType = payload.InputType, PayloadHex = Convert.ToHexString(payload.GetPayloadBytes()), Description = desc,
            RawData = Convert.ToHexString(tx.GetRawBytes()) });
    }

    private async Task Lock()
    {
        _sending = true; _error = null; _result = null;
        try
        {
            if (_lockAmount <= 0) { _error = "Amount must be positive."; return; }
            var tick = await GetTick();
            var payload = new Qubic.Core.Contracts.Qearn.LockPayload();
            await Broadcast(_lockAmount, tick, payload, $"QEarn Lock {_lockAmount:N0} QU");
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _sending = false; }
    }

    private async Task UnlockFromSummary(ActiveLock lk)
    {
        var earlyPct = GetEarlyUnlockRewardPercent(lk.Week);
        var msg = earlyPct >= 100
            ? $"Unlock {lk.Amount:N0} QU from epoch {lk.Epoch}?\n\nThis lock has reached full maturity — you will receive 100% of the reward."
            : $"Unlock {lk.Amount:N0} QU from epoch {lk.Epoch}?\n\nThis is an early unlock (week {lk.Week}/52). You will only receive {earlyPct}% of the full reward.";
        if (!await JS.InvokeAsync<bool>("confirm", msg))
            return;

        _sending = true; _error = null; _result = null; _unlockingEpoch = lk.Epoch;
        try
        {
            var tick = await GetTick();
            var payload = new Qubic.Core.Contracts.Qearn.UnlockPayload
            {
                Amount = lk.Amount, LockedEpoch = lk.Epoch
            };
            await Broadcast(0, tick, payload, $"QEarn Unlock {lk.Amount:N0} QU from epoch {lk.Epoch}");
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _sending = false; _unlockingEpoch = null; }
    }

    private byte[] GetUserPk()
    {
        var err = IdentityValidation.Validate(_qIdentity);
        if (err != null) throw new Exception("Identity: " + err);
        return Qubic.Core.Entities.QubicIdentity.FromIdentity(_qIdentity!.Trim()).PublicKey;
    }

    private async Task RunQuery()
    {
        _querying = true; _error = null; _queryResult = null; _lockStatusBits = null;
        try
        {
            byte[] input;
            switch (_queryFunc)
            {
                case 1: // GetLockInfoPerEpoch
                    input = new Qubic.Core.Contracts.Qearn.GetLockInfoPerEpochInput { Epoch = _qEpoch }.ToBytes();
                    break;
                case 2: // GetUserLockedInfo
                    input = new Qubic.Core.Contracts.Qearn.GetUserLockedInfoInput { User = GetUserPk(), Epoch = _qEpoch }.ToBytes();
                    break;
                case 3: // GetStateOfRound
                    input = new Qubic.Core.Contracts.Qearn.GetStateOfRoundInput { Epoch = _qEpoch }.ToBytes();
                    break;
                case 4: // GetUserLockStatus
                    input = new Qubic.Core.Contracts.Qearn.GetUserLockStatusInput { User = GetUserPk() }.ToBytes();
                    break;
                case 5: // GetEndedStatus
                    input = new Qubic.Core.Contracts.Qearn.GetEndedStatusInput { User = GetUserPk() }.ToBytes();
                    break;
                case 6: // GetStatsPerEpoch
                    input = new Qubic.Core.Contracts.Qearn.GetStatsPerEpochInput { Epoch = _qEpoch }.ToBytes();
                    break;
                case 7: // GetBurnedAndBoostedStats (empty input)
                    input = [];
                    break;
                case 8: // GetBurnedAndBoostedStatsPerEpoch
                    input = new Qubic.Core.Contracts.Qearn.GetBurnedAndBoostedStatsPerEpochInput { Epoch = _qEpoch }.ToBytes();
                    break;
                default: return;
            }

            var result = await Backend.QuerySmartContractAsync(ContractIndex, (uint)_queryFunc, input);
            _queryResult = ParseQueryResult(_queryFunc, result);
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _querying = false; }
    }

    /// Returns the percentage of full reward received if unlocking early at the given week.
    /// Based on the QEarn contract's early unlock schedule.
    private static int GetEarlyUnlockRewardPercent(int w)
    {
        if (w >= 52) return 100;
        if (w >= 48) return 55;
        if (w >= 44) return 50;
        if (w >= 40) return 45;
        if (w >= 36) return 40;
        if (w >= 32) return 35;
        if (w >= 28) return 30;
        if (w >= 24) return 25;
        if (w >= 20) return 20;
        if (w >= 16) return 15;
        if (w >= 12) return 10;
        if (w >= 8) return 5;
        if (w >= 4) return 5;
        return 0;
    }

    private List<KeyValuePair<string, string>> ParseQueryResult(int func, byte[] data)
    {
        var list = new List<KeyValuePair<string, string>>();
        switch (func)
        {
            case 1 when data.Length >= 40:
                var li = Qubic.Core.Contracts.Qearn.GetLockInfoPerEpochOutput.FromBytes(data);
                list.Add(new("Locked Amount", li.LockedAmount.ToString("N0")));
                list.Add(new("Bonus Amount", li.BonusAmount.ToString("N0")));
                list.Add(new("Current Locked Amount", li.CurrentLockedAmount.ToString("N0")));
                list.Add(new("Current Bonus Amount", li.CurrentBonusAmount.ToString("N0")));
                list.Add(new("Yield", li.Yield.ToString("N0")));
                break;

            case 2 when data.Length >= 8:
                var ui = Qubic.Core.Contracts.Qearn.GetUserLockedInfoOutput.FromBytes(data);
                list.Add(new("Locked Amount", ui.LockedAmount.ToString("N0")));
                break;

            case 3 when data.Length >= 4:
                var sr = Qubic.Core.Contracts.Qearn.GetStateOfRoundOutput.FromBytes(data);
                list.Add(new("State", sr.State.ToString()));
                break;

            case 4 when data.Length >= 8:
                var ls = Qubic.Core.Contracts.Qearn.GetUserLockStatusOutput.FromBytes(data);
                _lockStatusBits = ls.Status;
                var lockedCount = 0;
                for (int i = 0; i < 52; i++) if ((ls.Status >> i & 1) == 1) lockedCount++;
                list.Add(new("Status (raw)", ls.Status.ToString()));
                list.Add(new("Locked Weeks", $"{lockedCount} / 52"));
                break;

            case 5 when data.Length >= 32:
                var es = Qubic.Core.Contracts.Qearn.GetEndedStatusOutput.FromBytes(data);
                list.Add(new("Fully Unlocked Amount", es.FullyUnlockedAmount.ToString("N0")));
                list.Add(new("Fully Rewarded Amount", es.FullyRewardedAmount.ToString("N0")));
                list.Add(new("Early Unlocked Amount", es.EarlyUnlockedAmount.ToString("N0")));
                list.Add(new("Early Rewarded Amount", es.EarlyRewardedAmount.ToString("N0")));
                break;

            case 6 when data.Length >= 32:
                var sp = Qubic.Core.Contracts.Qearn.GetStatsPerEpochOutput.FromBytes(data);
                list.Add(new("Early Unlocked Amount", sp.EarlyUnlockedAmount.ToString("N0")));
                list.Add(new("Early Unlocked Percent", sp.EarlyUnlockedPercent.ToString("N0")));
                list.Add(new("Total Locked Amount", sp.TotalLockedAmount.ToString("N0")));
                list.Add(new("Average APY", sp.AverageAPY.ToString("N0")));
                break;

            case 7 when data.Length >= 48:
                var bb = Qubic.Core.Contracts.Qearn.GetBurnedAndBoostedStatsOutput.FromBytes(data);
                list.Add(new("Burned Amount", bb.BurnedAmount.ToString("N0")));
                list.Add(new("Avg Burned %", bb.AverageBurnedPercent.ToString("N0")));
                list.Add(new("Boosted Amount", bb.BoostedAmount.ToString("N0")));
                list.Add(new("Avg Boosted %", bb.AverageBoostedPercent.ToString("N0")));
                list.Add(new("Rewarded Amount", bb.RewardedAmount.ToString("N0")));
                list.Add(new("Avg Rewarded %", bb.AverageRewardedPercent.ToString("N0")));
                break;

            case 8 when data.Length >= 48:
                var bp = Qubic.Core.Contracts.Qearn.GetBurnedAndBoostedStatsPerEpochOutput.FromBytes(data);
                list.Add(new("Burned Amount", bp.BurnedAmount.ToString("N0")));
                list.Add(new("Burned %", bp.BurnedPercent.ToString("N0")));
                list.Add(new("Boosted Amount", bp.BoostedAmount.ToString("N0")));
                list.Add(new("Boosted %", bp.BoostedPercent.ToString("N0")));
                list.Add(new("Rewarded Amount", bp.RewardedAmount.ToString("N0")));
                list.Add(new("Rewarded %", bp.RewardedPercent.ToString("N0")));
                break;

            default:
                list.Add(new("Result", data.Length > 0 ? Convert.ToHexString(data) : "(empty)"));
                break;
        }
        return list;
    }
}
